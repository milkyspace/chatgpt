bot.py:
========================================
from __future__ import annotations
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.types import BotCommand
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties

from config import cfg
from router_public import router as public_router
from router_admin import router as admin_router
from services.payments_monitor import PaymentMonitor

import logging

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)

logger = logging.getLogger(__name__)


async def _set_commands(bot):
    await bot.set_my_commands([
        BotCommand(command="start", description="–ó–∞–ø—É—Å–∫ –∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
        BotCommand(command="new", description="–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç"),
        BotCommand(command="mode", description="–í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º"),
        BotCommand(command="subscription", description="–ú–æ—è –ø–æ–¥–ø–∏—Å–∫–∞"),
        BotCommand(command="help", description="–ü–æ–º–æ—â—å"),
    ])


async def main():
    logging.basicConfig(level=logging.INFO)
    logging.info(f"‚úÖ BOT_TOKEN: {cfg.bot_token[:10]}‚Ä¶")

    bot = Bot(
        token=cfg.bot_token,
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    await _set_commands(bot)

    dp = Dispatcher()
    dp.include_router(public_router)
    dp.include_router(admin_router)

    # –°–æ–∑–¥–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä –ø–ª–∞—Ç–µ–∂–µ–π —Å –ø–µ—Ä–µ–¥–∞—á–µ–π –±–æ—Ç–∞ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    monitor = PaymentMonitor(
        interval_min=cfg.payment_check_interval_min,
        bot=bot  # –ü–µ—Ä–µ–¥–∞–µ–º –±–æ—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    )
    asyncio.create_task(monitor.run_forever())

    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())

============================================================

code_collector.py:
========================================
import os
import glob


def simple_collect_code(output_file="project_code.txt"):
    """
    –ü—Ä–æ—Å—Ç–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Å–±–æ—Ä–∞ Python —Ñ–∞–π–ª–æ–≤
    """
    # –ò—â–µ–º –≤—Å–µ .py —Ñ–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö
    py_files = glob.glob('**/*.py', recursive=True)

    # –ò—Å–∫–ª—é—á–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    exclude_dirs = ['__pycache__', '.git', 'venv', 'env']
    filtered_files = [f for f in py_files if not any(exclude in f for exclude in exclude_dirs)]

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∏–º–µ–Ω–∏
    filtered_files.sort()

    with open(output_file, 'w', encoding='utf-8') as out_file:
        for file_path in filtered_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as in_file:
                    content = in_file.read()

                out_file.write(f"{file_path}:\n")
                out_file.write("=" * 40 + "\n")
                out_file.write(content)
                out_file.write("\n\n" + "=" * 60 + "\n\n")

                print(f"–î–æ–±–∞–≤–ª–µ–Ω: {file_path}")

            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ —Å —Ñ–∞–π–ª–æ–º {file_path}: {e}")

    print(f"\n–ì–æ—Ç–æ–≤–æ! –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {output_file}")


# –ó–∞–ø—É—Å–∫
if __name__ == "__main__":
    simple_collect_code()

============================================================

config.py:
========================================
from __future__ import annotations

from typing import List

from pydantic import BaseModel
import os
from dotenv import load_dotenv

load_dotenv()

class PlanConfig(BaseModel):
    code: str
    title: str
    price_rub: int
    duration_days: int
    max_requests: int | None       # None = –±–µ–∑–ª–∏–º–∏—Ç
    max_image_generations: int | None
    max_text_len: int              # –º–∞–∫—Å. —Å–∏–º–≤–æ–ª–æ–≤ –≤ –æ–¥–Ω–æ–º –∑–∞–ø—Ä–æ—Å–µ

class AppConfig(BaseModel):
    # Telegram
    admins: List[int] = [os.getenv("ADMIN_IDS", "")]
    bot_token: str = os.getenv("BOT_TOKEN", "")
    admin_ids: set[int] = set(map(int, os.getenv("ADMIN_IDS", "0").split(","))) if os.getenv("ADMIN_IDS") else set()

    # DB
    db_url: str = os.getenv("DATABASE_URL", "mysql+aiomysql://root:password@mariadb:3306/ai_bot_db")

    # OpenAI
    openai_api_key: str = os.getenv("OPENAI_API_KEY", "")
    openai_api_base: str | None = os.getenv("OPENAI_API_BASE")

    # –ü–ª–∞—Ç–µ–∂–∏ (YooMoney/–ÆKassa)
    payment_check_interval_min: float = float(os.getenv("PAYMENT_CHECK_INTERVAL_MIN", "1"))
    yookassa_shop_id: str | None = os.getenv("YOOKASSA_SHOP_ID")
    yookassa_secret_key: str | None = os.getenv("YOOKASSA_SECRET_KEY")
    yookassa_invoice_email: str | None = os.getenv("YOOKASSA_INVOICE_EMAIL")
    payment_provider: str = os.getenv("PAYMENT_PROVIDER", "yoomoney")  # yoomoney|mock

    # –¢–µ—Å—Ç–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥
    trial_days: int = 3
    trial_max_requests: int = 15
    trial_max_images: int = 3

    # –û—á–µ—Ä–µ–¥–∏
    workers_chat: int = 4
    workers_images: int = 2

    # –†–µ—Ñ–µ—Ä–∞–ª–∫–∞
    referral_bonus_days: int = 5

    # –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Ä–µ–∂–∏–º—ã
    modes: tuple[str, ...] = ("assistant", "image", "editor", "celebrity_selfie", "add_people")

    # –ü–ª–∞–Ω—ã (–ª–µ–≥–∫–æ –º–µ–Ω—è—Ç—å)
    plans: dict[str, PlanConfig] = {
        "pro_lite": PlanConfig(
            code="pro_lite", title="Pro Lite", price_rub=499, duration_days=10,
            max_requests=1000, max_image_generations=20, max_text_len=4000
        ),
        "pro_plus": PlanConfig(
            code="pro_plus", title="Pro Plus", price_rub=1290, duration_days=30,
            max_requests=None, max_image_generations=30, max_text_len=32000
        ),
        "pro_premium": PlanConfig(
            code="pro_premium", title="Pro Premium", price_rub=2990, duration_days=90,
            max_requests=None, max_image_generations=50, max_text_len=32000
        ),
    }

cfg = AppConfig()


============================================================

db.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import DeclarativeBase
from config import cfg

class Base(DeclarativeBase):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –º–æ–¥–µ–ª–µ–π."""

engine = create_async_engine(cfg.db_url, echo=False, pool_pre_ping=True)
AsyncSessionMaker = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

async def get_session() -> AsyncSession:
    """–§–∞–±—Ä–∏–∫–∞ —Å–µ—Å—Å–∏–π –¥–ª—è DI."""
    async with AsyncSessionMaker() as session:
        yield session


============================================================

keyboards.py:
========================================
from __future__ import annotations
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def subscriptions_keyboard() -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–¥–ø–∏—Å–∫–∏"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Pro Lite ‚Äî 499‚ÇΩ / 10 –¥–Ω–µ–π", callback_data="buy:pro_lite")],
        [InlineKeyboardButton(text="Pro Plus ‚Äî 1290‚ÇΩ / 30 –¥–Ω–µ–π", callback_data="buy:pro_plus")],
        [InlineKeyboardButton(text="Pro Premium ‚Äî 2990‚ÇΩ / 90 –¥–Ω–µ–π", callback_data="buy:pro_premium")],
    ])

def admin_menu() -> InlineKeyboardMarkup:
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", callback_data="admin:users"),
         InlineKeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin:stats")],
        [InlineKeyboardButton(text="üí≥ –ü–ª–∞—Ç–µ–∂–∏", callback_data="admin:payments"),
         InlineKeyboardButton(text="üì£ –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin:broadcast")],
        [InlineKeyboardButton(text="üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–ª–∞—Ç–µ–∂–∏", callback_data="admin:check_payments")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="panel:main")]
    ])

def admin_back_keyboard() -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –í –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="admin:main")]
    ])

def keyboards_for_modes() -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–æ–≤"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí¨ –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç", callback_data="mode:assistant"),
         InlineKeyboardButton(text="üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è", callback_data="mode:image")],
        [InlineKeyboardButton(text="üõ† –†–µ–¥–∞–∫—Ç–æ—Ä —Ñ–æ—Ç–æ", callback_data="mode:editor"),
         InlineKeyboardButton(text="ü§≥ –°–µ–ª—Ñ–∏ —Å–æ –∑–≤—ë–∑–¥–æ–π", callback_data="mode:celebrity_selfie")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="panel:main")],
    ])

def top_panel(bot_username: str, ref_code: str) -> InlineKeyboardMarkup:
    """–í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí≥ –ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="subs:show"),
         InlineKeyboardButton(text="üéõ –†–µ–∂–∏–º", callback_data="panel:mode")],
        [
            InlineKeyboardButton(
                text="üë• –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å",
                switch_inline_query=f"–ü–µ—Ä–µ—Ö–æ–¥–∏ –≤ https://t.me/{bot_username}?start={ref_code} ‚Äî –ø–æ–ª—É—á–∏ –±–æ–Ω—É—Å!"
            )
        ],
        [InlineKeyboardButton(text="‚ùì –ü–æ–º–æ—â—å", callback_data="panel:help"),
         InlineKeyboardButton(text="üõ° –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="panel:admin")],
    ])

def plan_buy_keyboard(plan_code: str, pay_url: str) -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã –ø–ª–∞–Ω–∞"""
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", url=pay_url)],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="subs:show")]
    ])

============================================================

models.py:
========================================
from __future__ import annotations
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import String, Integer, DateTime, ForeignKey, Boolean, Text
from sqlalchemy.sql import func
from db import Base
from typing import Optional
from datetime import datetime

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True)         # telegram user id
    username: Mapped[Optional[str]] = mapped_column(String(255))
    first_name: Mapped[Optional[str]] = mapped_column(String(255))
    last_name: Mapped[Optional[str]] = mapped_column(String(255))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    is_blocked: Mapped[bool] = mapped_column(Boolean, default=False)
    referral_code: Mapped[str] = mapped_column(String(32), unique=True)     # –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞-–∫–æ–¥
    referred_by: Mapped[Optional[int]] = mapped_column(Integer, ForeignKey("users.id"))

    # –æ—Ç–Ω–æ—à–µ–Ω–∏—è
    subscription: Mapped[Optional["UserSubscription"]] = relationship(back_populates="user", uselist=False)
    usage: Mapped[Optional["Usage"]] = relationship(back_populates="user", uselist=False)

class UserSubscription(Base):
    __tablename__ = "user_subscriptions"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), unique=True)
    plan_code: Mapped[Optional[str]] = mapped_column(String(64))     # None –æ–∑–Ω–∞—á–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é
    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    is_trial: Mapped[bool] = mapped_column(Boolean, default=True)

    user: Mapped["User"] = relationship(back_populates="subscription")

class Usage(Base):
    __tablename__ = "usage"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), unique=True)
    used_requests: Mapped[int] = mapped_column(Integer, default=0)
    used_images: Mapped[int] = mapped_column(Integer, default=0)

    user: Mapped["User"] = relationship(back_populates="usage")

class Payment(Base):
    __tablename__ = "payments"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(Integer, index=True)
    provider: Mapped[str] = mapped_column(String(64))
    provider_payment_id: Mapped[str] = mapped_column(String(128), index=True)
    plan_code: Mapped[str] = mapped_column(String(64))
    amount_rub: Mapped[int] = mapped_column(Integer)
    status: Mapped[str] = mapped_column(String(32), default="pending")  # pending/succeeded/canceled
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

class ChatSession(Base):
    __tablename__ = "chat_sessions"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(Integer, index=True)
    title: Mapped[str] = mapped_column(String(255))
    mode: Mapped[str] = mapped_column(String(32), default="assistant")
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)

class Message(Base):
    __tablename__ = "messages"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("chat_sessions.id"), index=True)
    role: Mapped[str] = mapped_column(String(32))  # user|assistant|system
    content: Mapped[str] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())


============================================================

payments/base.py:
========================================
from __future__ import annotations
from typing import Protocol, Tuple

class PaymentProvider(Protocol):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø–ª–∞—Ç—ë–∂–Ω–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞."""
    async def create_invoice(self, user_id: int, plan_code: str, amount_rub: int, description: str) -> Tuple[str, str]:
        """–°–æ–∑–¥–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (URL, payment_id)."""
        ...

    # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ/–≤–µ–±—Ö—É–∫ ‚Äî —Ä–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –≤–µ–±—Ö—É–∫–∞ (webhooks.py),
    # –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç services.subscriptions.activate_paid_plan(...)


============================================================

payments/mock.py:
========================================
from __future__ import annotations
from payments.base import PaymentProvider

class MockPaymentProvider(PaymentProvider):
    async def create_invoice(self, user_id: int, plan_code: str, amount_rub: int, description: str) -> tuple[str, str]:
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–µ–π–∫–æ–≤—É—é —Å—Å—ã–ª–∫—É –∏ ID –ø–ª–∞—Ç–µ–∂–∞
        payment_id = f"mock_payment_{user_id}_{plan_code}"
        return f"https://example.com/pay?user={user_id}&plan={plan_code}&sum={amount_rub}", payment_id

============================================================

payments/yoomoney.py:
========================================
from __future__ import annotations

import requests
from config import cfg
from yookassa import Configuration, Payment as YooPayment
import uuid

import logging

logger = logging.getLogger(__name__)


class YooMoneyProvider:
    """–ÆKassa —Å —Ä—É—á–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å—Ç–∞—Ç—É—Å–∞ (–±–µ–∑ –≤–µ–±—Ö—É–∫–æ–≤)."""

    def __init__(self):
        Configuration.account_id = cfg.yookassa_shop_id
        Configuration.secret_key = cfg.yookassa_secret_key
        self.email = cfg.yookassa_invoice_email

    async def create_invoice(self, user_id: int, plan_code: str, amount_rub: int, description: str) -> tuple[str, str]:
        """–°–æ–∑–¥–∞–µ—Ç –ø–ª–∞—Ç—ë–∂ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç (redirect_url, payment_id)"""
        idempotence_key = str(uuid.uuid4())
        try:
            payment = YooPayment.create({
                "amount": {
                    "value": f"{amount_rub:.2f}",
                    "currency": "RUB"
                },
                "confirmation": {
                    "type": "redirect",
                    "return_url": "https://yoomoney.ru"
                },
                "capture": True,
                "description": description or f"–ü–ª–∞–Ω {plan_code}",
                "receipt": {
                    "customer": {
                        "email": self.email,
                    },
                    "items": [
                        {
                            "description": description,
                            "quantity": "1.00",
                            "amount": {
                                "value": f"{amount_rub:.2f}",
                                "currency": "RUB"
                            },
                            "vat_code": "1",
                            "payment_mode": "full_payment",
                            "payment_subject": "commodity",
                        },
                    ]
                },
                "metadata": {
                    "user_id": str(user_id),
                    "plan_code": plan_code
                }
            }, idempotence_key)

            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏ URL –¥–ª—è —Ä–µ–¥–∏—Ä–µ–∫—Ç–∞, –∏ ID –ø–ª–∞—Ç–µ–∂–∞
            return payment.confirmation.confirmation_url, payment.id

        except requests.exceptions.HTTPError as e:
            logger.error(f"[YooKassa] –û—à–∏–±–∫–∞ HTTP: {e.response.text}")
            raise

    async def check_status(self, payment_id: str) -> str:
        payment = YooPayment.find_one(payment_id)
        return payment.status


============================================================

providers/base.py:
========================================
from __future__ import annotations
from typing import Protocol, Any, Sequence

class ChatProvider(Protocol):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —á–∞—Ç–∞."""
    async def chat(self, messages: Sequence[dict[str, str]], max_tokens: int, temperature: float = 0.7) -> str: ...

class ImageProvider(Protocol):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π."""
    async def generate(self, prompt: str) -> bytes: ...
    async def edit(self, image_bytes: bytes, instruction: str) -> bytes: ...
    async def add_people(self, image_bytes: bytes, description: str) -> bytes: ...
    async def celebrity_selfie(self, image_bytes: bytes, celebrity_name: str, style: str | None = None) -> bytes: ...


============================================================

providers/openai_provider.py:
========================================
from __future__ import annotations
from typing import Sequence, AsyncGenerator
from openai import AsyncOpenAI
from config import cfg
import httpx


class OpenAIChatProvider:
    """OpenAI GPT —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–æ—Ç–æ–∫–æ–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞ –∏ –∫–∞—Å—Ç–æ–º–Ω—ã–º httpx-–∫–ª–∏–µ–Ω—Ç–æ–º."""

    def __init__(self, model: str = "gpt-4o"):
        self.model = model
        self.http_client = httpx.AsyncClient(timeout=httpx.Timeout(60.0, connect=10.0))
        self.client = AsyncOpenAI(
            api_key=cfg.openai_api_key,
            base_url=cfg.openai_api_base,
            http_client=self.http_client
        )

    async def stream_chat(
            self, messages: Sequence[dict[str, str]], max_tokens: int = 800, temperature: float = 0.7
    ) -> AsyncGenerator[str, None]:
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Å—Ç—Ä–∏–º–∏–Ω–≥ OpenAI GPT-4o."""
        async with self.client.chat.completions.stream(
                model=self.model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
        ) as stream:
            async for event in stream:
                if event.type == "message.delta":
                    delta = event.delta.content or ""
                    if delta:
                        yield delta


class OpenAIImageProvider:
    """–ü—Ä–æ–≤–∞–π–¥–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ DALL-E —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º httpx-–∫–ª–∏–µ–Ω—Ç–æ–º."""

    def __init__(self, model: str = "dall-e-3"):  # ‚Üê –ò–ó–ú–ï–ù–ò–¢–ï –ó–î–ï–°–¨
        self.model = model
        self.http_client = httpx.AsyncClient(timeout=httpx.Timeout(120.0, connect=10.0))
        self.client = AsyncOpenAI(
            api_key=cfg.openai_api_key,
            base_url=cfg.openai_api_base,
            http_client=self.http_client,
        )

    async def generate(self, prompt: str) -> bytes:
        import base64
        try:
            response = await self.client.images.generate(
                model=self.model,
                prompt=prompt,
                size="1024x1024",
                n=1,
                response_format="b64_json"  # ‚Üê –î–û–ë–ê–í–¨–¢–ï –≠–¢–û
            )
            b64 = response.data[0].b64_json
            return base64.b64decode(b64)
        except Exception as e:
            print(f"OpenAI API Error: {e}")
            raise

    async def edit(self, image_bytes: bytes, instruction: str) -> bytes:
        prompt = f"–û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏: {instruction}"
        return await self.generate(prompt)

    async def add_people(self, image_bytes: bytes, description: str) -> bytes:
        prompt = f"–ù–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–æ—Ç–æ, –¥–æ–±–∞–≤—å –ª—é–¥–µ–π: {description}. –°–æ—Ö—Ä–∞–Ω–∏ —Å—Ç–∏–ª—å –∏ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç—å."
        return await self.generate(prompt)

    async def celebrity_selfie(self, image_bytes: bytes, celebrity_name: str, style: str | None = None) -> bytes:
        # –î–ª—è DALL-E –Ω–∞–º –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        prompt = f"–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–µ —Å–µ–ª—Ñ–∏ –¥–≤—É—Ö –ª—é–¥–µ–π. –û–¥–∏–Ω –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ {celebrity_name}, –≤—Ç–æ—Ä–æ–π - –æ–±—ã—á–Ω—ã–π —á–µ–ª–æ–≤–µ–∫. {style or ''} –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –¥–æ–ª–∂–Ω–∞ –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–µ–µ —Å–µ–ª—Ñ–∏, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ, –≤—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ."
        return await self.generate(prompt)

============================================================

queue_bg.py:
========================================
from __future__ import annotations
import asyncio
from typing import Callable, Awaitable, Any

class AsyncWorkerPool:
    """–ü—Ä–æ—Å—Ç–æ–π –ø—É–ª –≤–æ—Ä–∫–µ—Ä–æ–≤. –ö–ª–∞–¥–µ–º –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥—å ‚Äî –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –≤ —Ñ–æ–Ω–µ."""
    def __init__(self, workers: int):
        self.queue: asyncio.Queue[Callable[[], Awaitable[Any]]] = asyncio.Queue()
        self.workers = workers
        self._tasks: list[asyncio.Task] = []

    async def start(self):
        for _ in range(self.workers):
            self._tasks.append(asyncio.create_task(self._worker()))

    async def _worker(self):
        while True:
            job = await self.queue.get()
            try:
                await job()
            except Exception:
                # –ª–æ–≥–∏—Ä—É–µ–º/–º–µ—Ç—Ä–∏–∫–∏ ‚Äî –æ–ø—É—â–µ–Ω–æ
                pass
            finally:
                self.queue.task_done()

    async def submit(self, coro_factory: Callable[[], Awaitable[Any]]):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–¥–∞—á—É (–ª–µ–Ω–∏–≤—É—é —Ñ–∞–±—Ä–∏–∫—É –∫–æ—Ä—É—Ç–∏–Ω—ã) –≤ –æ—á–µ—Ä–µ–¥—å."""
        await self.queue.put(coro_factory)

    async def stop(self):
        for t in self._tasks:
            t.cancel()


============================================================

router_admin.py:
========================================
from __future__ import annotations

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message as TgMessage, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy import func
from sqlalchemy import select, update
import asyncio
import logging

from config import cfg
from db import AsyncSessionMaker
from keyboards import admin_menu, admin_back_keyboard
from models import Payment, User, UserSubscription
from payments.yoomoney import YooMoneyProvider
from services.subscriptions import activate_paid_plan
from services.auth import is_admin

logger = logging.getLogger(__name__)

# –°–æ–∑–¥–∞–µ–º —Ñ–∏–ª—å—Ç—Ä –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
admin_filter = F.from_user.func(lambda user: is_admin(user.id))

router = Router()

# –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä –∫–æ –≤—Å–µ–º —Ö–µ–Ω–¥–ª–µ—Ä–∞–º —ç—Ç–æ–≥–æ —Ä–æ—É—Ç–µ—Ä–∞
router.message.filter(admin_filter)
router.callback_query.filter(admin_filter)


@router.message(Command("admin"))
async def admin_entry(m: TgMessage):
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏"""
    await m.answer(
        "üõ° <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:\n"
        "‚Ä¢ üë§ –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
        "‚Ä¢ üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
        "‚Ä¢ üí≥ –ü–ª–∞—Ç–µ–∂–∏\n"
        "‚Ä¢ üì£ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π\n"
        "‚Ä¢ üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π",
        reply_markup=admin_menu()
    )


@router.callback_query(F.data == "admin:main")
async def admin_main(cq: CallbackQuery):
    """–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏"""
    await cq.message.edit_text(
        "üõ° <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:\n"
        "‚Ä¢ üë§ –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
        "‚Ä¢ üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
        "‚Ä¢ üí≥ –ü–ª–∞—Ç–µ–∂–∏\n"
        "‚Ä¢ üì£ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π\n"
        "‚Ä¢ üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π",
        reply_markup=admin_menu()
    )
    await cq.answer()


@router.callback_query(F.data == "admin:users")
async def admin_users(cq: CallbackQuery):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    async with AsyncSessionMaker() as session:
        total_users = await session.scalar(select(func.count()).select_from(User))
        active_subs = await session.scalar(
            select(func.count()).select_from(UserSubscription).where(
                UserSubscription.expires_at > func.now()
            )
        )
        trial_users = await session.scalar(
            select(func.count()).select_from(UserSubscription).where(
                UserSubscription.is_trial == True
            )
        )

    text = (
        f"üë• <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>\n\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: <b>{total_users}</b>\n"
        f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫: <b>{active_subs}</b>\n"
        f"‚Ä¢ –ü—Ä–æ–±–Ω—ã—Ö –ø–µ—Ä–∏–æ–¥–æ–≤: <b>{trial_users}</b>"
    )
    await cq.message.edit_text(text, reply_markup=admin_back_keyboard())
    await cq.answer()


@router.callback_query(F.data == "admin:stats")
async def admin_stats(cq: CallbackQuery):
    """–ü–æ–¥—Ä–æ–±–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"""
    async with AsyncSessionMaker() as session:
        # –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        total_users = await session.scalar(select(func.count()).select_from(User))
        total_payments = await session.scalar(select(func.count()).select_from(Payment))
        successful_payments = await session.scalar(
            select(func.count()).select_from(Payment).where(Payment.status == "succeeded")
        )
        total_revenue = await session.scalar(
            select(func.sum(Payment.amount_rub)).where(Payment.status == "succeeded")
        ) or 0

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–ª–∞–Ω–∞–º
        plan_stats = {}
        for plan_code in cfg.plans.keys():
            count = await session.scalar(
                select(func.count()).select_from(Payment).where(
                    Payment.plan_code == plan_code,
                    Payment.status == "succeeded"
                )
            )
            plan_stats[plan_code] = count

    text = (
        "üìä <b>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>\n\n"
        f"‚Ä¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: <b>{total_users}</b>\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –ø–ª–∞—Ç–µ–∂–µ–π: <b>{total_payments}</b>\n"
        f"‚Ä¢ –£—Å–ø–µ—à–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π: <b>{successful_payments}</b>\n"
        f"‚Ä¢ –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞: <b>{total_revenue} ‚ÇΩ</b>\n\n"
        "<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç–∞—Ä–∏—Ñ–∞–º:</b>\n"
    )

    for plan_code, count in plan_stats.items():
        plan = cfg.plans.get(plan_code)
        plan_name = plan.title if plan else plan_code
        text += f"‚Ä¢ {plan_name}: <b>{count}</b>\n"

    await cq.message.edit_text(text, reply_markup=admin_back_keyboard())
    await cq.answer()


@router.callback_query(F.data == "admin:payments")
async def admin_payments(cq: CallbackQuery):
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–ª–∞—Ç–µ–∂–∞–º"""
    async with AsyncSessionMaker() as session:
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—Ç–∞—Ç—É—Å–∞–º –ø–ª–∞—Ç–µ–∂–µ–π
        status_stats = await session.execute(
            select(Payment.status, func.count(Payment.id))
            .group_by(Payment.status)
        )
        status_counts = dict(status_stats.all())

        # –û–∂–∏–¥–∞—é—â–∏–µ –ø–ª–∞—Ç–µ–∂–∏
        pending_count = await session.scalar(
            select(func.count()).select_from(Payment).where(Payment.status == "pending")
        )

    text = "üí≥ <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π</b>\n\n<b>–ü–æ —Å—Ç–∞—Ç—É—Å–∞–º:</b>\n"

    for status, count in status_counts.items():
        text += f"‚Ä¢ {status}: <b>{count}</b>\n"

    text += f"\n<b>–û–∂–∏–¥–∞—é—â–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏:</b> <b>{pending_count}</b>"

    await cq.message.edit_text(text, reply_markup=admin_back_keyboard())
    await cq.answer()


@router.callback_query(F.data == "admin:check_payments")
async def admin_check_payments(cq: CallbackQuery):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π"""
    provider = YooMoneyProvider()

    async with AsyncSessionMaker() as session:
        payments = await session.scalars(
            select(Payment).where(Payment.status == "pending")
        )
        pending_payments = payments.all()

        if not pending_payments:
            await cq.message.edit_text(
                "‚úÖ –ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π",
                reply_markup=admin_back_keyboard()
            )
            await cq.answer()
            return

        processed = 0
        succeeded = 0

        for payment in pending_payments:
            try:
                # –î–ª—è –∞–¥–º–∏–Ω–æ–≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–ª–∞—Ç–µ–∂–∏
                if is_admin(payment.user_id):
                    status = "succeeded"
                else:
                    status = await provider.check_status(payment.provider_payment_id)

                if status == "succeeded":
                    await activate_paid_plan(session, payment.user_id, payment.plan_code)
                    payment.status = "succeeded"
                    succeeded += 1
                elif status in ("canceled", "expired"):
                    payment.status = status

                processed += 1

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ {payment.id}: {e}")
                continue

        await session.commit()

    await cq.message.edit_text(
        f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π –∑–∞–≤–µ—Ä—à–µ–Ω–∞:\n"
        f"‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {processed}\n"
        f"‚Ä¢ –£—Å–ø–µ—à–Ω—ã—Ö: {succeeded}\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –≤ –æ—á–µ—Ä–µ–¥–∏: {len(pending_payments)}",
        reply_markup=admin_back_keyboard()
    )
    await cq.answer()


@router.callback_query(F.data == "admin:broadcast")
async def admin_broadcast(cq: CallbackQuery):
    """–ù–∞—á–∞–ª–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Ä–∞—Å—Å—ã–ª–∫–∏"""
    await cq.message.edit_text(
        "üì£ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n"
        "–°–æ–æ–±—â–µ–Ω–∏–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –±–æ—Ç–∞.\n\n"
        "<i>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ HTML-—Ä–∞–∑–º–µ—Ç–∫—É –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.</i>",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞", callback_data="admin:main")]
        ])
    )
    await cq.answer()


@router.message(F.reply_to_message & F.reply_to_message.text.contains("–†–∞—Å—Å—ã–ª–∫–∞"))
async def process_broadcast(m: TgMessage):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–∞—Å—Å—ã–ª–∫—É"""
    broadcast_text = m.text

    if not broadcast_text or len(broadcast_text.strip()) < 5:
        await m.answer("‚ùå –¢–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π")
        return

    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    async with AsyncSessionMaker() as session:
        users = await session.scalars(select(User))
        user_list = users.all()

    processing_msg = await m.answer(f"üîÑ –ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è {len(user_list)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")

    success_count = 0
    fail_count = 0

    for user in user_list:
        try:
            await m.bot.send_message(
                chat_id=user.id,
                text=broadcast_text,
                parse_mode="HTML"
            )
            success_count += 1
            # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å –ª–∏–º–∏—Ç—ã Telegram
            await asyncio.sleep(0.1)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.id}: {e}")
            fail_count += 1

    await processing_msg.edit_text(
        f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞:\n"
        f"‚Ä¢ –£—Å–ø–µ—à–Ω–æ: {success_count}\n"
        f"‚Ä¢ –ù–µ —É–¥–∞–ª–æ—Å—å: {fail_count}\n"
        f"‚Ä¢ –í—Å–µ–≥–æ: {len(user_list)}",
        reply_markup=admin_back_keyboard()
    )


@router.message(Command("check_payments"))
async def check_payments_command(m: TgMessage):
    """–†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É"""
    provider = YooMoneyProvider()

    async with AsyncSessionMaker() as session:
        payments = await session.scalars(
            select(Payment).where(Payment.status == "pending")
        )
        pending_payments = payments.all()

        if not pending_payments:
            await m.answer("‚úÖ –ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π")
            return

        processed = 0
        succeeded = 0

        for payment in pending_payments:
            try:
                # –î–ª—è –∞–¥–º–∏–Ω–æ–≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–ª–∞—Ç–µ–∂–∏
                if is_admin(payment.user_id):
                    status = "succeeded"
                else:
                    status = await provider.check_status(payment.provider_payment_id)

                if status == "succeeded":
                    await activate_paid_plan(session, payment.user_id, payment.plan_code)
                    payment.status = "succeeded"
                    succeeded += 1
                elif status in ("canceled", "expired"):
                    payment.status = status

                processed += 1

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ {payment.id}: {e}")
                continue

        await session.commit()

    await m.answer(
        f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π –∑–∞–≤–µ—Ä—à–µ–Ω–∞:\n"
        f"‚Ä¢ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {processed}\n"
        f"‚Ä¢ –£—Å–ø–µ—à–Ω—ã—Ö: {succeeded}\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –≤ –æ—á–µ—Ä–µ–¥–∏: {len(pending_payments)}"
    )

@router.callback_query(F.data == "panel:admin")
async def panel_admin(cq: CallbackQuery):
    """–ü–µ—Ä–µ—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"""
    if not is_admin(cq.from_user.id):
        await cq.answer("üö´ –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return

    await cq.message.edit_text(
        "üõ° <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:\n"
        "‚Ä¢ üë§ –ü—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
        "‚Ä¢ üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n"
        "‚Ä¢ üí≥ –ü–ª–∞—Ç–µ–∂–∏\n"
        "‚Ä¢ üì£ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π\n"
        "‚Ä¢ üîÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π",
        reply_markup=admin_menu()  # –¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è!
    )
    await cq.answer()

============================================================

router_public.py:
========================================
from __future__ import annotations

from datetime import datetime, timezone

from aiogram import Router, F
from aiogram.filters import Command, CommandStart
from aiogram.types import Message as TgMessage, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy import select
from sqlalchemy import update
from aiogram.types import CallbackQuery, User, Chat

from config import cfg
from db import AsyncSessionMaker
from keyboards import plan_buy_keyboard
from keyboards import top_panel, keyboards_for_modes
from models import (
    User,
    ChatSession,
    UserSubscription,
    Usage,
    Payment,
)
from payments.yoomoney import YooMoneyProvider
from queue_bg import AsyncWorkerPool
from services.chat import ChatService
from services.images import ImageService
from services.subscriptions import ensure_user, get_limits
from services.usage import can_spend_request, spend_request, can_spend_image, spend_image
from services.subscriptions import has_active_subscription
from utils import store_message, get_history, trim_messages

router = Router()

# –ü—É–ª—ã —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
chat_pool = AsyncWorkerPool(cfg.workers_chat)
img_pool = AsyncWorkerPool(cfg.workers_images)


@router.startup()
async def _startup(bot):
    """–ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤—ã—Ö –ø—É–ª–æ–≤ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –±–æ—Ç–∞."""
    await chat_pool.start()
    await img_pool.start()


@router.shutdown()
async def _shutdown(bot):
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–æ–Ω–æ–≤—ã—Ö –ø—É–ª–æ–≤ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã."""
    await chat_pool.stop()
    await img_pool.stop()


async def _render_status_line(session, user_id: int) -> str:
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    now = datetime.now(timezone.utc)  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º UTC

    expires_at = None
    if sub and sub.expires_at:
        # –ü—Ä–∏–≤–æ–¥–∏–º –¥–∞—Ç—É –∫ UTC –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
        expires_at = sub.expires_at
        if expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        else:
            expires_at = expires_at.astimezone(timezone.utc)

    if not sub or not expires_at or expires_at <= now:
        status = "üî¥ –ù–µ–∞–∫—Ç–∏–≤–Ω–∞"
        expires_str = "‚Äî"
        plan_name = "–ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∏—Å—Ç—ë–∫" if (sub and sub.is_trial) else "–ù–µ—Ç"
        limits = "–ó–∞–ø—Ä–æ—Å—ã: 0 / –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: 0"
    else:
        plan_code = sub.plan_code or "trial"
        plan_conf = cfg.plans.get(plan_code)
        status = "üü¢ –ê–∫—Ç–∏–≤–Ω–∞"
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        expires_str = expires_at.astimezone().strftime("%d.%m.%Y %H:%M")
        if sub.is_trial:
            plan_name = "Trial"
            max_req, max_img, _ = cfg.trial_max_requests, cfg.trial_max_images, 4000
        else:
            plan_name = plan_conf.title if plan_conf else plan_code
            max_req = plan_conf.max_requests
            max_img = plan_conf.max_image_generations
        ur = usage.used_requests if usage else 0
        ui = usage.used_images if usage else 0
        limits = f"–ó–∞–ø—Ä–æ—Å—ã: {('‚àû' if max_req is None else f'{ur}/{max_req}')}, " \
                 f"–ò–∑–æ–±—Ä.: {('‚àû' if max_img is None else f'{ui}/{max_img}')}"

    text = f"<b>–ü–æ–¥–ø–∏—Å–∫–∞:</b> {status}\n" \
           f"<b>–¢–∞—Ä–∏—Ñ:</b> {plan_name}\n"
    if expires_str:
        text += f"<b>–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ:</b> {expires_str}\n"
        text += f"<b>–õ–∏–º–∏—Ç—ã:</b> {limits}"

    return text


@router.message(CommandStart())
async def start(m: TgMessage):
    ref_code = None
    if m.text and " " in m.text:
        ref_code = m.text.split(" ", 1)[1].strip()

    async with AsyncSessionMaker() as session:
        user = await ensure_user(session, m.from_user.id, m.from_user.username,
                                 m.from_user.first_name, m.from_user.last_name, ref_code)
        status = await _render_status_line(session, m.from_user.id)

    me = await m.bot.get_me()  # ‚Üê –≤–æ—Ç –∑–¥–µ—Å—å –ø–æ–ª—É—á–∞–µ–º –∏–º—è –±–æ—Ç–∞
    await m.answer(
        status,
        reply_markup=top_panel(me.username, user.referral_code)  # ‚Üê –ø–µ—Ä–µ–¥–∞—ë–º –µ–≥–æ —Å—é–¥–∞
    )


@router.message(Command("mode"))
async def cmd_mode(m: TgMessage):
    await m.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º:", reply_markup=keyboards_for_modes())


@router.message(Command("subscription"))
async def cmd_subscription(m: TgMessage):
    await show_subscription_panel(m)


@router.message(Command("help"))
async def cmd_help(m: TgMessage):
    text = (
        "‚ÑπÔ∏è <b>–ü–æ–º–æ—â—å</b>\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "‚Ä¢ /start ‚Äî –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
        "‚Ä¢ /mode ‚Äî –≤—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞\n"
        "‚Ä¢ /subscription ‚Äî –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ\n"
        "‚Ä¢ /new ‚Äî –Ω–æ–≤—ã–π —á–∞—Ç\n\n"
        "–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, –∏ –±–æ—Ç –æ—Ç–≤–µ—Ç–∏—Ç –≤–∞–º ü§ñ"
    )
    await m.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="panel:main")]
    ]))


@router.message(Command("new"))
async def cmd_new_chat(m: TgMessage):
    """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞"""
    async with AsyncSessionMaker() as session:
        # –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —á–∞—Ç—ã
        await session.execute(update(ChatSession).where(
            ChatSession.user_id == m.from_user.id,
            ChatSession.is_active == True
        ).values(is_active=False))

        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —á–∞—Ç
        new_session = ChatSession(
            user_id=m.from_user.id,
            title="–ù–æ–≤—ã–π —á–∞—Ç",
            mode="assistant",
            is_active=True
        )
        session.add(new_session)
        await session.commit()

    await m.answer("‚úÖ –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —á–∞—Ç. –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è.")


@router.callback_query(F.data == "panel:referral")
async def panel_referral(cq: CallbackQuery):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ"""
    async with AsyncSessionMaker() as session:
        user_row = await session.scalar(
            select(User).where(User.id == cq.from_user.id)
        )

    if not user_row:
        await cq.answer("–û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    me = await cq.bot.get_me()
    referral_url = f"https://t.me/{me.username}?start={user_row.referral_code}"

    text = (
        "üë´ <b>–ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ –±–æ–Ω—É—Å—ã!</b>\n\n"
        f"–í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:\n<code>{referral_url}</code>\n\n"
        "–ó–∞ –∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞, –∫–æ—Ç–æ—Ä—ã–π –æ–ø–ª–∞—Ç–∏—Ç –ø–æ–¥–ø–∏—Å–∫—É:\n"
        "‚Ä¢ <b>–í–∞–º</b> ‚Äì +5 –¥–Ω–µ–π –∫ –ø–æ–¥–ø–∏—Å–∫–µ\n"
        "‚Ä¢ <b>–î—Ä—É–≥—É</b> ‚Äì 7 –¥–Ω–µ–π –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞\n\n"
        "–ü—Ä–æ—Å—Ç–æ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π —Å –¥—Ä—É–∑—å—è–º–∏!"
    )

    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üì§ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è —Å—Å—ã–ª–∫–æ–π",
                              switch_inline_query=f"–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Å—è! {referral_url}")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="panel:main")]
    ])

    await cq.message.edit_text(text, reply_markup=keyboard)
    await cq.answer()


@router.message(Command("admin"))
async def cmd_admin(m: TgMessage):
    if m.from_user.id not in cfg.admin_ids:
        await m.answer("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.")
        return

    await m.answer(
        "üõ° <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n"
        "1Ô∏è‚É£ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n"
        "2Ô∏è‚É£ –†–∞—Å—Å—ã–ª–∫–∏\n"
        "3Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π\n\n"
        "‚öôÔ∏è –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="panel:main")]
        ])
    )


@router.callback_query(F.data == "panel:mode")
async def panel_mode(cq: CallbackQuery):
    await cq.message.edit_reply_markup(reply_markup=keyboards_for_modes())
    await cq.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º")


@router.callback_query(F.data == "panel:help")
async def panel_help(cq: CallbackQuery):
    text = (
        "‚ÑπÔ∏è <b>–ü–æ–º–æ—â—å</b>\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "‚Ä¢ /start ‚Äî –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
        "‚Ä¢ /new ‚Äî –Ω–æ–≤—ã–π —á–∞—Ç\n"
        "‚Ä¢ /mode ‚Äî –≤—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º\n"
        "‚Ä¢ /subscription ‚Äî –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ\n"
        "‚Ä¢ –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç ‚Äî –∏ –ø–æ–ª—É—á–∏—Ç–µ –æ—Ç–≤–µ—Ç\n\n"
        "–ü–æ–¥–¥–µ—Ä–∂–∫–∞: @your_support_username"
    )
    await cq.message.edit_text(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="panel:main")]
    ]))
    await cq.answer()


@router.callback_query(F.data.startswith("mode:"))
async def switch_mode(cq: CallbackQuery):
    mode = cq.data.split(":", 1)[1]
    if mode not in cfg.modes:
        await cq.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ —Ä–µ–∂–∏–º—É
    async with AsyncSessionMaker() as session:
        has_access = await has_active_subscription(session, cq.from_user.id)

        if not has_access:
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ–º –ø–æ–¥–ø–∏—Å–∫–∏
            text = (
                f"üö´ <b>–î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω</b>\n\n"
                f"üíé <b>–û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É</b> —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º:"
            )
            await cq.message.edit_text(text)
            await cq.answer()

            await show_subs(cq, False)

            return

    async with AsyncSessionMaker() as session:
        # —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é —á–∞—Ç–∞ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ
        res = await session.execute(select(ChatSession).where(
            ChatSession.user_id == cq.from_user.id, ChatSession.is_active == True))
        active = res.scalars().first()
        if active:
            active.is_active = False
        session.add(ChatSession(user_id=cq.from_user.id, title=f"{mode.capitalize()} —á–∞—Ç", mode=mode, is_active=True))
        await session.commit()
    await cq.message.answer(f"–†–µ–∂–∏–º –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω: {mode}")
    await cq.answer()


def format_plan_info(code: str) -> str:
    plan = cfg.plans[code]
    limits = []
    limits.append("–ó–∞–ø—Ä–æ—Å—ã: ‚àû" if plan.max_requests is None else f"–ó–∞–ø—Ä–æ—Å—ã: –¥–æ {plan.max_requests}")
    limits.append(
        "–ì–µ–Ω–µ—Ä–∞—Ü–∏–∏: ‚àû" if plan.max_image_generations is None else f"–ì–µ–Ω–µ—Ä–∞—Ü–∏–∏: –¥–æ {plan.max_image_generations}")
    limits.append(f"–î–ª–∏–Ω–∞ –∑–∞–ø—Ä–æ—Å–∞: –¥–æ {plan.max_text_len} —Å–∏–º–≤–æ–ª–æ–≤")
    return (f"<b>{plan.title}</b>\n"
            f"–°—Ç–æ–∏–º–æ—Å—Ç—å: <b>{plan.price_rub} ‚ÇΩ</b> / {plan.duration_days} –¥–Ω–µ–π\n"
            f"{' ‚Ä¢ '.join(limits)}")


@router.callback_query(F.data == "subs:show")
async def show_subs(cq: CallbackQuery, is_edit: bool = True):
    text = (
        "üí≥ <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏</b>\n\n"
        f"{format_plan_info('pro_lite')}\n\n"
        f"{format_plan_info('pro_plus')}\n\n"
        f"{format_plan_info('pro_premium')}\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π —Ç–∞—Ä–∏—Ñ –¥–ª—è –æ–ø–ª–∞—Ç—ã."
    )
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ö—É–ø–∏—Ç—å Pro Lite", callback_data="buy:pro_lite")],
        [InlineKeyboardButton(text="–ö—É–ø–∏—Ç—å Pro Plus", callback_data="buy:pro_plus")],
        [InlineKeyboardButton(text="–ö—É–ø–∏—Ç—å Pro Premium", callback_data="buy:pro_premium")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="panel:main")],
    ])
    if is_edit:
        await cq.message.edit_text(text=text, reply_markup=kb)
        await cq.answer()
    else:
        await cq.message.answer(text=text, reply_markup=kb)


@router.callback_query(F.data.startswith("buy:"))
async def buy(cq: CallbackQuery):
    plan = cq.data.split(":", 1)[1]
    plan_conf = cfg.plans[plan]
    provider = YooMoneyProvider() if cfg.payment_provider == "yoomoney" else None
    description = f"–û–ø–ª–∞—Ç–∞ –ø–ª–∞–Ω–∞ {plan_conf.title}"

    # —Å–æ–∑–¥–∞–µ–º –ø–ª–∞—Ç—ë–∂ –∏ –ø–æ–ª—É—á–∞–µ–º URL –∏ ID –ø–ª–∞—Ç–µ–∂–∞
    pay_url, payment_id = await provider.create_invoice(cq.from_user.id, plan, plan_conf.price_rub, description)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞—Ç–µ–∂–µ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    async with AsyncSessionMaker() as session:
        payment = Payment(
            user_id=cq.from_user.id,
            provider=cfg.payment_provider,
            provider_payment_id=payment_id,
            plan_code=plan,
            amount_rub=plan_conf.price_rub,
            status="pending"
        )
        session.add(payment)
        await session.commit()

    # –∫—Ä–∞—Å–∏–≤—ã–π —Ç–µ–∫—Å—Ç + –∫—Ä–∞—Å–∏–≤–∞—è –∫–Ω–æ–ø–∫–∞
    text = (
        f"üßæ <b>–°—á—ë—Ç –Ω–∞ –æ–ø–ª–∞—Ç—É</b>\n\n"
        f"<b>–¢–∞—Ä–∏—Ñ:</b> {plan_conf.title}\n"
        f"<b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {plan_conf.price_rub} ‚ÇΩ –∑–∞ {plan_conf.duration_days} –¥–Ω–µ–π\n"
        f"<b>–ß—Ç–æ –≤—Ö–æ–¥–∏—Ç:</b>\n"
        f"‚Ä¢ –ó–∞–ø—Ä–æ—Å—ã: {'‚àû' if plan_conf.max_requests is None else plan_conf.max_requests}\n"
        f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {'‚àû' if plan_conf.max_image_generations is None else plan_conf.max_image_generations}\n"
        f"‚Ä¢ –î–ª–∏–Ω–∞ –∑–∞–ø—Ä–æ—Å–∞: –¥–æ {plan_conf.max_text_len} —Å–∏–º–≤–æ–ª–æ–≤\n\n"
        f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ üëá"
    )
    await cq.message.answer(text, reply_markup=plan_buy_keyboard(plan, pay_url))
    await cq.answer()


@router.message(F.photo)
async def on_photo(m: TgMessage):
    """–ü—Ä–∏–Ω–∏–º–∞–µ–º —Ñ–æ—Ç–æ. –†–∞–±–æ—Ç–∞–µ–º –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ: editor/add_people/celebrity_selfie."""
    file_id = m.photo[-1].file_id
    mode = "editor"
    async with AsyncSessionMaker() as session:
        # —É–∑–Ω–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é –∏ –ª–∏–º–∏—Ç—ã
        res = await session.execute(
            select(ChatSession).where(ChatSession.user_id == m.from_user.id, ChatSession.is_active == True))
        chat_sess = res.scalars().first()
        if chat_sess:
            mode = chat_sess.mode
        max_req, max_img, max_text_len = await get_limits(session, m.from_user.id)
        if not await can_spend_image(session, m.from_user.id):
            await m.answer("–õ–∏–º–∏—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω. –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –∏–ª–∏ –ø–æ–¥–æ–∂–¥–∏—Ç–µ –ø—Ä–æ–¥–ª–µ–Ω–∏—è.")
            return

    # –ø–æ–¥–≥—Ä—É–∂–∞–µ–º bytes —Ñ–æ—Ç–æ
    photo_file = await m.bot.get_file(file_id)
    photo_bytes = await m.bot.download_file(photo_file.file_path)

    img_service = ImageService()

    # –ó–∞–¥–∞—á–∞ –≤ —Ñ–æ–Ω–µ
    async def job():
        new_img: bytes | None = None
        error: str | None = None
        if mode == "editor":
            instruction = m.caption or "–°–ª–µ–≥–∫–∞ —É–ª—É—á—à–∏—Ç—å –∫–∞—á–µ—Å—Ç–≤–æ –∏ —Ü–≤–µ—Ç."
            new_img, error = await img_service.edit(photo_bytes.read(), instruction)
        elif mode == "add_people":
            desc = m.caption or "–î–æ–±–∞–≤–∏—Ç—å –¥–≤—É—Ö –ª—é–¥–µ–π –Ω–∞ –∑–∞–¥–Ω–∏–π –ø–ª–∞–Ω, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è."
            new_img, error = await img_service.add_people(photo_bytes.read(), desc)
        elif mode == "celebrity_selfie":
            celeb = (m.caption or "–ò–∑–≤–µ—Å—Ç–Ω–∞—è –ª–∏—á–Ω–æ—Å—Ç—å").strip()
            new_img, error = await img_service.celebrity_selfie(photo_bytes.read(), celeb)
        else:
            new_img, error = await img_service.edit(photo_bytes.read(), "–£–ª—É—á—à–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")

        if error:
            await m.answer(f"‚ùóÔ∏è {error}")
            return

        if new_img:
            await m.answer_photo(new_img, caption=f"–ì–æ—Ç–æ–≤–æ! –†–µ–∂–∏–º: {mode}")
            async with AsyncSessionMaker() as session:
                await spend_image(session, m.from_user.id)

    await img_pool.submit(job)


@router.message(F.text & ~F.via_bot)
async def on_text(m: TgMessage):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–±—ã—á–Ω—ã–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–º —Ä–µ–∂–∏–º–µ."""
    text = m.text.strip()
    user_id = m.from_user.id

    # —Ä–µ–∂–∏–º (–Ω–∞–ø—Ä–∏–º–µ—Ä assistant / image) ‚Äî –ø–æ–ª—É—á–∞–µ–º –∏–∑ –±–∞–∑—ã, –Ω–æ –ø–æ–∫–∞ –ø—É—Å—Ç—å –¥–µ—Ñ–æ–ª—Ç
    mode = "assistant"

    if mode == "assistant":
        chat_service = ChatService()
        await chat_service.handle_user_message(text, m.bot, m.chat.id)
    else:
        await m.answer("‚öôÔ∏è –î—Ä—É–≥–∏–µ —Ä–µ–∂–∏–º—ã –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.")


@router.callback_query(F.data == "chat:new")
async def new_chat(cq: CallbackQuery):
    async with AsyncSessionMaker() as session:
        # –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –≤—Å–µ –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π assistant
        await session.execute(update(ChatSession).where(
            ChatSession.user_id == cq.from_user.id, ChatSession.is_active == True
        ).values(is_active=False))
        session.add(ChatSession(user_id=cq.from_user.id, title="–ù–æ–≤—ã–π —á–∞—Ç", mode="assistant", is_active=True))
        await session.commit()
    await cq.message.answer("–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —á–∞—Ç. –ü–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
    await cq.answer()


@router.callback_query(F.data == "chat:list")
async def chat_list(cq: CallbackQuery):
    PAGE_SIZE = 10
    page = 1
    if cq.message and cq.message.reply_markup:
        # –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–∞–≥–∏–Ω–∞—Ü–∏—é —á–µ—Ä–µ–∑ callback_data –≤–∏–¥–∞ chat:list:2
        pass
    async with AsyncSessionMaker() as session:
        rows = (await session.execute(
            select(ChatSession).where(ChatSession.user_id == cq.from_user.id).order_by(ChatSession.id.desc()).limit(100)
        )).scalars().all()

    if not rows:
        await cq.message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤.")
        await cq.answer()
        return

    lines = []
    for s in rows[:PAGE_SIZE]:
        mark = "üü¢" if s.is_active else "‚ö™Ô∏è"
        lines.append(f"{mark} <b>{s.title}</b> ‚Äî {s.mode} (#{s.id})")
    text = "üìÅ <b>–í–∞—à–∏ —á–∞—Ç—ã</b>\n" + "\n".join(lines)
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π", callback_data=f"chat:activate:{rows[0].id}")],
        [InlineKeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π", callback_data="chat:new")]
    ])
    await cq.message.answer(text, reply_markup=kb)
    await cq.answer()


@router.callback_query(F.data.startswith("chat:activate:"))
async def chat_activate(cq: CallbackQuery):
    sess_id = int(cq.data.split(":")[-1])
    async with AsyncSessionMaker() as session:
        await session.execute(update(ChatSession).where(
            ChatSession.user_id == cq.from_user.id, ChatSession.is_active == True
        ).values(is_active=False))
        await session.execute(update(ChatSession).where(
            ChatSession.id == sess_id, ChatSession.user_id == cq.from_user.id
        ).values(is_active=True))
        await session.commit()
    await cq.message.answer(f"‚úîÔ∏è –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —á–∞—Ç #{sess_id}")
    await cq.answer()


async def show_subscription_panel(m: TgMessage):
    async with AsyncSessionMaker() as session:
        status = await _render_status_line(session, m.from_user.id)
        user_row = (await session.execute(select(User).where(User.id == m.from_user.id))).scalars().first()
    me = await m.bot.get_me()
    await m.answer(status, reply_markup=top_panel(me.username, user_row.referral_code))


@router.callback_query(F.data == "panel:main")
async def panel_main(cq: CallbackQuery):
    async with AsyncSessionMaker() as session:
        status = await _render_status_line(session, cq.from_user.id)
        user_row = (await session.execute(
            select(User).where(User.id == cq.from_user.id)
        )).scalars().first()
    me = await cq.bot.get_me()
    await cq.message.edit_text(status, reply_markup=top_panel(me.username, user_row.referral_code))
    await cq.answer()


============================================================

services/auth.py:
========================================
from __future__ import annotations
from config import cfg


def is_admin(user_id: int) -> bool:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º

    Args:
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Telegram

    Returns:
        bool: True –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä
    """
    return user_id in cfg.admin_ids


async def admin_required(user_id: int) -> bool:
    """
    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (–¥–ª—è —Ñ–∏–ª—å—Ç—Ä–æ–≤)

    Args:
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Telegram

    Returns:
        bool: True –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä
    """
    return is_admin(user_id)

============================================================

services/chat.py:
========================================
from __future__ import annotations
from providers.openai_provider import OpenAIChatProvider
from services.safety import SafetyGuard

class ChatService:
    def __init__(self, provider=None):
        self.provider = provider or OpenAIChatProvider(model="gpt-4o")

    async def handle_user_message(self, message: str, bot, chat_id: int):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫–æ–≤—ã–π –æ—Ç–≤–µ—Ç GPT."""
        sent = await bot.send_message(chat_id, "ü§î –î—É–º–∞—é‚Ä¶")
        full_text = ""
        async for delta in self.provider.stream_chat([{"role": "user", "content": message}]):
            full_text += delta
            try:
                await bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=sent.message_id,
                    text=f"üí¨ {full_text}"
                )
            except Exception:
                pass
        await bot.edit_message_text(
            chat_id=chat_id,
            message_id=sent.message_id,
            text=f"üí¨ {full_text}"
        )

============================================================

services/images.py:
========================================
from __future__ import annotations
from providers.openai_provider import OpenAIImageProvider
from services.safety import SafetyGuard, SafetyDecision


class ImageService:
    """–§–∞—Å–∞–¥ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π. –õ–µ–≥–∫–æ –∑–∞–º–µ–Ω–∏—Ç—å –ø—Ä–æ–≤–∞–π–¥–µ—Ä."""

    def __init__(self, provider: OpenAIImageProvider | None = None):
        self.provider = provider or OpenAIImageProvider()

    async def generate(self, prompt: str) -> tuple[bytes | None, str | None]:
        try:
            img = await self.provider.generate(prompt)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {str(e)}"

    async def edit(self, image_bytes: bytes, instruction: str) -> tuple[bytes | None, str | None]:
        try:
            img = await self.provider.edit(image_bytes, instruction)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {str(e)}"

    async def add_people(self, image_bytes: bytes, description: str) -> tuple[bytes | None, str | None]:
        try:
            img = await self.provider.add_people(image_bytes, description)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ª—é–¥–µ–π: {str(e)}"

    async def celebrity_selfie(self, image_bytes: bytes, celebrity_name: str, style: str | None = None) -> tuple[
        bytes | None, str | None]:
        # SafetyGate: –±–ª–æ–∫–∏—Ä—É–µ–º deepfake —Å–æ –∑–Ω–∞–º–µ–Ω–∏—Ç–æ—Å—Ç—è–º–∏
        dec: SafetyDecision = SafetyGuard.check_celebrity_selfie(celebrity_name)
        if not dec.allowed:
            return None, dec.reason or "–û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–ø—Ä–µ—â–µ–Ω–∞ –ø–æ–ª–∏—Ç–∏–∫–∞–º–∏."

        try:
            img = await self.provider.celebrity_selfie(image_bytes, celebrity_name, style)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ–ª—Ñ–∏: {str(e)}"

============================================================

services/notifications.py:
========================================
from __future__ import annotations
from aiogram import Bot
from datetime import datetime
from config import cfg


class NotificationService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"""

    def __init__(self, bot: Bot):
        self.bot = bot

    async def send_subscription_activated(
            self,
            user_id: int,
            plan_title: str,
            expires_at: datetime
    ) -> None:
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏

        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Telegram
            plan_title: –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–∞—Ä–∏—Ñ–Ω–æ–≥–æ –ø–ª–∞–Ω–∞
            expires_at: –î–∞—Ç–∞ –∏—Å—Ç–µ—á–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏
        """
        try:
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –≤ —Ä—É—Å—Å–∫–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
            expires_str = expires_at.strftime("%d.%m.%Y %H:%M")

            # –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –≤–∞—à–µ–º—É –ø—Ä–∏–º–µ—Ä—É
            message_text = (
                "üöÄ –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!\n"
                f"–¢–∞—Ä–∏—Ñ: {plan_title} –¥–æ {expires_str} –ú–°–ö.\n"
                "–°–ø–∞—Å–∏–±–æ, —á—Ç–æ –≤—ã–±—Ä–∞–ª–∏ –Ω–∞—à —Å–µ—Ä–≤–∏—Å!\n\n"

                "üíå –ü–æ–¥–∞—Ä–æ—á–Ω—ã–µ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã\n"
                "–•–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å –Ω–µ–æ–±—ã—á–Ω—ã–π –ø–æ–¥–∞—Ä–æ–∫? –£ –Ω–∞—Å –µ—Å—Ç—å —Å—Ç–∏–ª—å–Ω—ã–µ —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–µ "
                "—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã –Ω–∞ –ø–æ–¥–ø–∏—Å–∫—É ‚Äì –∏–¥–µ–∞–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è –±–ª–∏–∑–∫–∏—Ö –∏ –¥—Ä—É–∑–µ–π!\n\n"

                "üë´ –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ –±–æ–Ω—É—Å—ã:\n"
                "‚Ä¢ –í–∞–º ‚Äì +1 –º–µ—Å—è—Ü –±–µ—Å–ø–ª–∞—Ç–Ω–æ –∑–∞ –∫–∞–∂–¥–æ–≥–æ –ø—Ä–∏–≥–ª–∞—à—ë–Ω–Ω–æ–≥–æ –¥—Ä—É–≥–∞ —Å –æ–ø–ª–∞—á–µ–Ω–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–æ–π\n"
                "‚Ä¢ –í–∞—à–∏–º –¥—Ä—É–∑—å—è–º ‚Äì 7 –¥–Ω–µ–π –±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞\n\n"

                "–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –≤–æ–ø—Ä–æ—Å—ã, –º—ã –≤—Å–µ–≥–¥–∞ —Ä–∞–¥—ã –ø–æ–º–æ—á—å!\n"
                "–ü—Ä–∏—è—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è! ü´∂"
            )

            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏
            from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
            keyboard = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üë´ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–≥–∞", callback_data="panel:referral")],
                [InlineKeyboardButton(text="‚ùì –ü–æ–º–æ—â—å", callback_data="panel:help")]
            ])

            await self.bot.send_message(
                chat_id=user_id,
                text=message_text,
                reply_markup=keyboard,
                parse_mode="HTML"
            )

        except Exception as e:
            # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –Ω–æ –Ω–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")

    async def send_payment_failed(self, user_id: int, reason: str) -> None:
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–µ—É–¥–∞—á–Ω–æ–º –ø–ª–∞—Ç–µ–∂–µ

        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Telegram
            reason: –ü—Ä–∏—á–∏–Ω–∞ –æ—Ç–∫–∞–∑–∞
        """
        try:
            message_text = (
                "‚ùå –ü–ª–∞—Ç–µ–∂ –Ω–µ –ø—Ä–æ—à–µ–ª\n\n"
                f"–ü—Ä–∏—á–∏–Ω–∞: {reason}\n\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É."
            )

            await self.bot.send_message(chat_id=user_id, text=message_text)

        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ –ø–ª–∞—Ç–µ–∂–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")

============================================================

services/payments_monitor.py:
========================================
from __future__ import annotations
import asyncio
import logging
from sqlalchemy import select, update
from db import AsyncSessionMaker
from models import Payment, User
from payments.yoomoney import YooMoneyProvider
from services.subscriptions import activate_paid_plan
from services.referrals import apply_referral_bonus
from services.notifications import NotificationService
from services.auth import is_admin  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à—É –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é

logger = logging.getLogger(__name__)


class PaymentMonitor:
    """–§–æ–Ω–æ–≤—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–ª–∞—Ç–µ–∂–µ–π."""

    def __init__(self, interval_min: float = 1, bot=None):
        self.interval_min = interval_min
        self.running = False
        self.bot = bot
        self.notification_service = NotificationService(bot) if bot else None

    async def run_forever(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∫–∏."""
        self.running = True
        provider = YooMoneyProvider()
        logger.info(f"[PaymentMonitor] –ó–∞–ø—É—â–µ–Ω. –ò–Ω—Ç–µ—Ä–≤–∞–ª: {self.interval_min} –º–∏–Ω—É—Ç.")
        while self.running:
            try:
                await self.check_pending(provider)
            except Exception as e:
                logger.exception(f"[PaymentMonitor] –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}")
            await asyncio.sleep(self.interval_min * 60)

    async def stop(self):
        self.running = False

    async def check_pending(self, provider: YooMoneyProvider):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤—Å–µ –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏."""
        async with AsyncSessionMaker() as session:
            payments = (await session.execute(
                select(Payment).where(Payment.status == "pending")
            )).scalars().all()

            if not payments:
                return

            for payment in payments:
                await self._process_payment(session, provider, payment)

    async def _process_payment(self, session, provider: YooMoneyProvider, payment: Payment):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–¥–∏–Ω –ø–ª–∞—Ç–µ–∂"""
        try:
            # –î–ª—è –∞–¥–º–∏–Ω–æ–≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–ª–∞—Ç–µ–∂–∏
            if is_admin(payment.user_id):  # –¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é
                logger.info(f"–ê–¥–º–∏–Ω—Å–∫–∏–π –ø–ª–∞—Ç–µ–∂ {payment.provider_payment_id}: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {payment.user_id}")
                status = "succeeded"
            else:
                status = await provider.check_status(payment.provider_payment_id)

            logger.info(f"–ü–ª–∞—Ç–µ–∂ {payment.provider_payment_id}: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {payment.user_id} : —Å—Ç–∞—Ç—É—Å {status}")

            if status == "succeeded":
                await self._handle_successful_payment(session, payment)
            elif status in ("canceled", "expired"):
                await self._handle_failed_payment(session, payment, status)

        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —Å—Ç–∞—Ç—É—Å–∞ –¥–ª—è –ø–ª–∞—Ç–µ–∂–∞ {payment.id}: {e}")

    async def _handle_successful_payment(self, session, payment: Payment):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —É—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç–µ–∂"""
        logger.info(f"–ü–ª–∞—Ç–µ–∂ {payment.id} ({payment.plan_code}) –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω.")

        # –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É
        subscription = await activate_paid_plan(session, payment.user_id, payment.plan_code)

        # –ù–∞—á–∏—Å–ª—è–µ–º –±–æ–Ω—É—Å —Ä–µ—Ñ–µ—Ä–µ—Ä—É
        user = await session.get(User, payment.user_id)
        if user and user.referred_by:
            await apply_referral_bonus(session, user.referred_by)

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞
        await session.execute(
            update(Payment)
            .where(Payment.id == payment.id)
            .values(status="succeeded")
        )
        await session.commit()

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        if self.notification_service and subscription:
            from config import cfg  # –õ–æ–∫–∞–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
            plan = cfg.plans.get(payment.plan_code)
            plan_title = plan.title if plan else payment.plan_code
            await self.notification_service.send_subscription_activated(
                user_id=payment.user_id,
                plan_title=plan_title,
                expires_at=subscription.expires_at
            )

    async def _handle_failed_payment(self, session, payment: Payment, status: str):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–µ—É–¥–∞—á–Ω—ã–π –ø–ª–∞—Ç–µ–∂"""
        logger.info(f"–ü–ª–∞—Ç–µ–∂ {payment.id} –æ—Ç–º–µ–Ω–µ–Ω ({status}).")

        await session.execute(
            update(Payment)
            .where(Payment.id == payment.id)
            .values(status=status)
        )
        await session.commit()

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
        if self.notification_service:
            reason = "–æ—Ç–º–µ–Ω–µ–Ω" if status == "canceled" else "–∏—Å—Ç–µ–∫ —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è"
            await self.notification_service.send_payment_failed(
                user_id=payment.user_id,
                reason=reason
            )

============================================================

services/referrals.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import timedelta, datetime, timezone
from config import cfg
from models import UserSubscription


async def apply_referral_bonus(session: AsyncSession, referrer_user_id: int) -> None:
    """–î–∞—Ä–∏–º —Ä–µ—Ñ–µ—Ä–µ—Ä—É +N –¥–Ω–µ–π –∫ —Ç–µ–∫—É—â–µ–π –ø–æ–¥–ø–∏—Å–∫–µ."""
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == referrer_user_id))
    now = datetime.now(timezone.utc)  # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º UTC
    bonus = timedelta(days=cfg.referral_bonus_days)

    if not sub:
        sub = UserSubscription(user_id=referrer_user_id, is_trial=False, plan_code="pro_lite")
        session.add(sub)

    # –ü—Ä–∏–≤–æ–¥–∏–º expires_at –∫ UTC –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    if sub.expires_at:
        expires_at = sub.expires_at
        if expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        else:
            expires_at = expires_at.astimezone(timezone.utc)

        if expires_at > now:
            sub.expires_at = expires_at + bonus
        else:
            sub.expires_at = now + bonus
    else:
        sub.expires_at = now + bonus

    await session.commit()

============================================================

services/safety.py:
========================================
from __future__ import annotations

class SafetyDecision:
    def __init__(self, allowed: bool, reason: str | None = None):
        self.allowed = allowed
        self.reason = reason

class SafetyGuard:
    """–ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞. –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –≤–Ω–µ–¥—Ä–∏—Ç—å —Å–≤–æ–∏ –ø—Ä–∞–≤–∏–ª–∞ –∏/–∏–ª–∏ –º–æ–¥–µ—Ä–∞—Ü–∏—é –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤."""
    BLOCKED_CELEBRITY_SELFIE = False  # –ø—Ä–∏–º–µ—Ä —Ñ–ª–∞–≥–∞ ‚Äî –¥–ª—è OpenAI –ª—É—á—à–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å deepfake —Å –ø—É–±–ª–∏—á–Ω—ã–º–∏ —Ñ–∏–≥—É—Ä–∞–º–∏

    @classmethod
    def check_celebrity_selfie(cls, celebrity_name: str) -> SafetyDecision:
        if cls.BLOCKED_CELEBRITY_SELFIE:
            return SafetyDecision(False, "–°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å —É—á–∞—Å—Ç–∏–µ–º –∑–Ω–∞–º–µ–Ω–∏—Ç–æ—Å—Ç–µ–π –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –ø–æ–ª–∏—Ç–∏–∫–∞–º–∏. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º.")
        return SafetyDecision(True)

    @classmethod
    def check_text_length(cls, text: str, max_len: int) -> SafetyDecision:
        if len(text) > max_len:
            return SafetyDecision(False, f"–ü—Ä–µ–≤—ã—à–µ–Ω–∞ –¥–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞ ({len(text)} > {max_len}). –£–∫–æ—Ä–æ—Ç–∏—Ç–µ –∑–∞–ø—Ä–æ—Å.")
        return SafetyDecision(True)


============================================================

services/subscriptions.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import datetime, timedelta, timezone
from config import cfg
from models import User, UserSubscription, Usage


async def ensure_user(session: AsyncSession, tg_user_id: int, username: str | None, first_name: str | None,
                      last_name: str | None, referred_by_code: str | None = None) -> User:
    """–°–æ–∑–¥–∞—ë—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –ø–æ–¥–ø–∏—Å–∫—É trial –∏ usage –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—Ö–æ–¥–µ."""
    user = await session.scalar(select(User).where(User.id == tg_user_id))
    if user:
        return user

    # –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ—Ñ. –∫–æ–¥
    ref_code = f"ref{tg_user_id}"
    user = User(
        id=tg_user_id, username=username, first_name=first_name, last_name=last_name, referral_code=ref_code
    )
    session.add(user)
    await session.flush()

    # —Å–≤—è–∑—ã–≤–∞–µ–º —Ä–µ—Ñ–µ—Ä–∞
    if referred_by_code:
        referrer = await session.scalar(select(User).where(User.referral_code == referred_by_code))
        if referrer:
            user.referred_by = referrer.id

    # —Å–æ–∑–¥–∞–µ–º trial –ø–æ–¥–ø–∏—Å–∫—É
    sub = UserSubscription(
        user_id=user.id,
        plan_code=None,
        is_trial=True,
        expires_at=datetime.now(timezone.utc) + timedelta(days=cfg.trial_days),
    )
    session.add(sub)
    # usage
    usage = Usage(user_id=user.id, used_requests=0, used_images=0)
    session.add(usage)

    await session.commit()
    return user


async def has_active_subscription(session: AsyncSession, user_id: int) -> bool:
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    if not sub or not sub.expires_at:
        return False
    # –ü—Ä–∏–≤–æ–¥–∏–º –æ–±–µ –¥–∞—Ç—ã –∫ UTC –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    now = datetime.now(timezone.utc)
    expires_at = sub.expires_at
    if expires_at.tzinfo is None:
        expires_at = expires_at.replace(tzinfo=timezone.utc)
    else:
        expires_at = expires_at.astimezone(timezone.utc)
    return expires_at > now


async def get_limits(session: AsyncSession, user_id: int) -> tuple[int | None, int | None, int]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (max_requests, max_images, max_text_len) –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–ª–∞–Ω–∞/—Ç—Ä–∏–∞–ª–∞."""
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    if not sub:
        # –±–µ–∑ –ø–æ–¥–ø–∏—Å–∫–∏ ‚Äî –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞
        return (0, 0, 0)
    if sub.is_trial:
        return (cfg.trial_max_requests, cfg.trial_max_images, 4000)
    plan = cfg.plans.get(sub.plan_code or "", None)
    if not plan:
        return (0, 0, 0)
    return (plan.max_requests, plan.max_image_generations, plan.max_text_len)


async def activate_paid_plan(session: AsyncSession, user_id: int, plan_code: str) -> UserSubscription:
    """
    –ê–∫—Ç–∏–≤–∞—Ü–∏—è –ø–ª–∞—Ç–Ω–æ–≥–æ –ø–ª–∞–Ω–∞ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã).
    –ü—Ä–æ–¥–ª–µ–≤–∞–µ—Ç –≤—Ä–µ–º—è –∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç usage.

    Args:
        session: –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Å–µ—Å—Å–∏—è –ë–î
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        plan_code: –ö–æ–¥ –ø–ª–∞–Ω–∞

    Returns:
        UserSubscription: –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞
    """
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    now = datetime.now(timezone.utc)

    if not sub:
        sub = UserSubscription(user_id=user_id)
        session.add(sub)

    plan = cfg.plans[plan_code]

    # –ü—Ä–∏–≤–æ–¥–∏–º expires_at –∫ UTC –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
    if sub.expires_at:
        expires_at = sub.expires_at
        if expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)
        else:
            expires_at = expires_at.astimezone(timezone.utc)

        if expires_at > now:
            sub.expires_at = expires_at + timedelta(days=plan.duration_days)
        else:
            sub.expires_at = now + timedelta(days=plan.duration_days)
    else:
        sub.expires_at = now + timedelta(days=plan.duration_days)

    sub.plan_code = plan_code
    sub.is_trial = False

    # –°–±—Ä–æ—Å usage –ø–æ–¥ –Ω–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    if usage:
        usage.used_requests = 0
        usage.used_images = 0

    await session.commit()
    return sub  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–¥–ø–∏—Å–∫—É –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è—Ö

============================================================

services/usage.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models import Usage
from services.subscriptions import get_limits

async def can_spend_request(session: AsyncSession, user_id: int) -> bool:
    max_req, _, _ = await get_limits(session, user_id)
    if max_req is None:
        return True
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    return usage.used_requests < max_req

async def can_spend_image(session: AsyncSession, user_id: int) -> bool:
    _, max_img, _ = await get_limits(session, user_id)
    if max_img is None:
        return True
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    return usage.used_images < max_img

async def spend_request(session: AsyncSession, user_id: int) -> None:
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    usage.used_requests += 1
    await session.commit()

async def spend_image(session: AsyncSession, user_id: int) -> None:
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    usage.used_images += 1
    await session.commit()


============================================================

utils.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models import User, UserSubscription, Usage, ChatSession, Message
from services.subscriptions import get_limits
from typing import Iterable

async def require_active_subscription(session: AsyncSession, user_id: int) -> bool:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –∏ –Ω–µ –∏—Å—Ç—ë–∫ trial."""
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    if not sub or not sub.expires_at:
        return False
    return sub.expires_at.timestamp() > __import__("time").time()

async def store_message(session: AsyncSession, session_id: int, role: str, content: str) -> None:
    m = Message(session_id=session_id, role=role, content=content)
    session.add(m)
    await session.commit()

async def get_history(session: AsyncSession, session_id: int, limit: int = 30) -> list[dict[str, str]]:
    res = (await session.execute(
        select(Message).where(Message.session_id == session_id).order_by(Message.id.desc()).limit(limit)
    )).scalars().all()
    out: list[dict[str, str]] = [{"role": m.role, "content": m.content} for m in reversed(res)]
    return out

def trim_messages(tokens_est: int, messages: list[dict[str, str]], max_len: int) -> list[dict[str, str]]:
    """–ü—Ä–æ—Å—Ç–æ–µ —É—Å–µ—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ –¥–ª–∏–Ω–µ —Ç–µ–∫—Å—Ç–∞ (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)."""
    total = 0
    out: list[dict[str, str]] = []
    for m in reversed(messages):
        l = len(m.get("content", ""))
        if total + l > max_len:
            break
        out.append(m)
        total += l
    return list(reversed(out))


============================================================

