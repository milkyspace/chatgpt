bot.py:
========================================
from __future__ import annotations
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.types import BotCommand
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties

from config import cfg
from router_public import router as public_router
from router_admin import router as admin_router
from services.payments_monitor import PaymentMonitor


import logging

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)

logger = logging.getLogger(__name__)


async def _set_commands(bot):
    await bot.set_my_commands([
        BotCommand(command="start", description="–ó–∞–ø—É—Å–∫ –∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
        BotCommand(command="new", description="–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç"),
        BotCommand(command="mode", description="–í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º"),
        BotCommand(command="subscription", description="–ú–æ—è –ø–æ–¥–ø–∏—Å–∫–∞"),
        BotCommand(command="help", description="–ü–æ–º–æ—â—å"),
    ])

async def main():
    logging.basicConfig(level=logging.INFO)
    logging.info(f"‚úÖ BOT_TOKEN: {cfg.bot_token[:10]}‚Ä¶")

    bot = Bot(
        token=cfg.bot_token,
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    await _set_commands(bot)
    
    dp = Dispatcher()
    dp.include_router(public_router)
    dp.include_router(admin_router)

    monitor = PaymentMonitor(interval_min=cfg.payment_check_interval_min)
    asyncio.create_task(monitor.run_forever())

    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())


============================================================

code_collector.py:
========================================
import os
import glob


def simple_collect_code(output_file="project_code.txt"):
    """
    –ü—Ä–æ—Å—Ç–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Å–±–æ—Ä–∞ Python —Ñ–∞–π–ª–æ–≤
    """
    # –ò—â–µ–º –≤—Å–µ .py —Ñ–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö
    py_files = glob.glob('**/*.py', recursive=True)

    # –ò—Å–∫–ª—é—á–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    exclude_dirs = ['__pycache__', '.git', 'venv', 'env']
    filtered_files = [f for f in py_files if not any(exclude in f for exclude in exclude_dirs)]

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∏–º–µ–Ω–∏
    filtered_files.sort()

    with open(output_file, 'w', encoding='utf-8') as out_file:
        for file_path in filtered_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as in_file:
                    content = in_file.read()

                out_file.write(f"{file_path}:\n")
                out_file.write("=" * 40 + "\n")
                out_file.write(content)
                out_file.write("\n\n" + "=" * 60 + "\n\n")

                print(f"–î–æ–±–∞–≤–ª–µ–Ω: {file_path}")

            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ —Å —Ñ–∞–π–ª–æ–º {file_path}: {e}")

    print(f"\n–ì–æ—Ç–æ–≤–æ! –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {output_file}")


# –ó–∞–ø—É—Å–∫
if __name__ == "__main__":
    simple_collect_code()

============================================================

config.py:
========================================
from __future__ import annotations

from typing import List

from pydantic import BaseModel
import os
from dotenv import load_dotenv

load_dotenv()

class PlanConfig(BaseModel):
    code: str
    title: str
    price_rub: int
    duration_days: int
    max_requests: int | None       # None = –±–µ–∑–ª–∏–º–∏—Ç
    max_image_generations: int | None
    max_text_len: int              # –º–∞–∫—Å. —Å–∏–º–≤–æ–ª–æ–≤ –≤ –æ–¥–Ω–æ–º –∑–∞–ø—Ä–æ—Å–µ

class AppConfig(BaseModel):
    # Telegram
    admins: List[int] = [os.getenv("ADMIN_IDS", "")]
    bot_token: str = os.getenv("BOT_TOKEN", "")
    admin_ids: set[int] = set(map(int, os.getenv("ADMIN_IDS", "0").split(","))) if os.getenv("ADMIN_IDS") else set()

    # DB
    db_url: str = os.getenv("DATABASE_URL", "mysql+aiomysql://root:password@mariadb:3306/ai_bot_db")

    # OpenAI
    openai_api_key: str = os.getenv("OPENAI_API_KEY", "")
    openai_api_base: str | None = os.getenv("OPENAI_API_BASE")

    # –ü–ª–∞—Ç–µ–∂–∏ (YooMoney/–ÆKassa)
    payment_check_interval_min: float = float(os.getenv("PAYMENT_CHECK_INTERVAL_MIN", "1"))
    yookassa_shop_id: str | None = os.getenv("YOOKASSA_SHOP_ID")
    yookassa_secret_key: str | None = os.getenv("YOOKASSA_SECRET_KEY")
    yookassa_invoice_email: str | None = os.getenv("YOOKASSA_INVOICE_EMAIL")
    payment_provider: str = os.getenv("PAYMENT_PROVIDER", "yoomoney")  # yoomoney|mock

    # –¢–µ—Å—Ç–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥
    trial_days: int = 3
    trial_max_requests: int = 15
    trial_max_images: int = 3

    # –û—á–µ—Ä–µ–¥–∏
    workers_chat: int = 4
    workers_images: int = 2

    # –†–µ—Ñ–µ—Ä–∞–ª–∫–∞
    referral_bonus_days: int = 5

    # –†–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Ä–µ–∂–∏–º—ã
    modes: tuple[str, ...] = ("assistant", "image", "editor", "celebrity_selfie", "add_people")

    # –ü–ª–∞–Ω—ã (–ª–µ–≥–∫–æ –º–µ–Ω—è—Ç—å)
    plans: dict[str, PlanConfig] = {
        "pro_lite": PlanConfig(
            code="pro_lite", title="Pro Lite", price_rub=499, duration_days=10,
            max_requests=1000, max_image_generations=20, max_text_len=4000
        ),
        "pro_plus": PlanConfig(
            code="pro_plus", title="Pro Plus", price_rub=1290, duration_days=30,
            max_requests=None, max_image_generations=30, max_text_len=32000
        ),
        "pro_premium": PlanConfig(
            code="pro_premium", title="Pro Premium", price_rub=2990, duration_days=90,
            max_requests=None, max_image_generations=50, max_text_len=32000
        ),
    }

cfg = AppConfig()


============================================================

db.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import DeclarativeBase
from config import cfg

class Base(DeclarativeBase):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –º–æ–¥–µ–ª–µ–π."""

engine = create_async_engine(cfg.db_url, echo=False, pool_pre_ping=True)
AsyncSessionMaker = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

async def get_session() -> AsyncSession:
    """–§–∞–±—Ä–∏–∫–∞ —Å–µ—Å—Å–∏–π –¥–ª—è DI."""
    async with AsyncSessionMaker() as session:
        yield session


============================================================

keyboards.py:
========================================
from __future__ import annotations
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def subscriptions_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Pro Lite ‚Äî 499‚ÇΩ / 10 –¥–Ω–µ–π", callback_data="buy:pro_lite")],
        [InlineKeyboardButton(text="Pro Plus ‚Äî 1290‚ÇΩ / 30 –¥–Ω–µ–π", callback_data="buy:pro_plus")],
        [InlineKeyboardButton(text="Pro Premium ‚Äî 2990‚ÇΩ / 90 –¥–Ω–µ–π", callback_data="buy:pro_premium")],
    ])

def admin_menu() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", callback_data="admin:users"),
         InlineKeyboardButton(text="üì£ –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin:broadcast")],
        [InlineKeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin:stats")]
    ])

def keyboards_for_modes() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí¨ –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç", callback_data="mode:assistant"),
         InlineKeyboardButton(text="üé® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è", callback_data="mode:image")],
        [InlineKeyboardButton(text="üõ† –†–µ–¥–∞–∫—Ç–æ—Ä —Ñ–æ—Ç–æ", callback_data="mode:editor"),
         InlineKeyboardButton(text="ü§≥ –°–µ–ª—Ñ–∏ —Å–æ –∑–≤—ë–∑–¥–æ–π", callback_data="mode:celebrity_selfie")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="panel:main")],  # ‚Üê –Ω–æ–≤–∞—è –∫–Ω–æ–ø–∫–∞
    ])

def top_panel(bot_username: str, ref_code: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí≥ –ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="subs:show"),
         InlineKeyboardButton(text="üéõ –†–µ–∂–∏–º", callback_data="panel:mode")],
        [
            InlineKeyboardButton(
                text="üë• –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å",
                switch_inline_query=f"–ü–µ—Ä–µ—Ö–æ–¥–∏ –≤ https://t.me/{bot_username}?start={ref_code} ‚Äî –ø–æ–ª—É—á–∏ –±–æ–Ω—É—Å!"
            )
        ],
        [InlineKeyboardButton(text="‚ùì –ü–æ–º–æ—â—å", callback_data="panel:help"),
         InlineKeyboardButton(text="üõ° –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å", callback_data="panel:admin")],
    ])

def plan_buy_keyboard(plan_code: str, pay_url: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", url=pay_url)],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="subs:show")]
    ])

============================================================

models.py:
========================================
from __future__ import annotations
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import String, Integer, DateTime, ForeignKey, Boolean, Text
from sqlalchemy.sql import func
from db import Base
from typing import Optional
from datetime import datetime

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True)         # telegram user id
    username: Mapped[Optional[str]] = mapped_column(String(255))
    first_name: Mapped[Optional[str]] = mapped_column(String(255))
    last_name: Mapped[Optional[str]] = mapped_column(String(255))
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    is_blocked: Mapped[bool] = mapped_column(Boolean, default=False)
    referral_code: Mapped[str] = mapped_column(String(32), unique=True)     # –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞-–∫–æ–¥
    referred_by: Mapped[Optional[int]] = mapped_column(Integer, ForeignKey("users.id"))

    # –æ—Ç–Ω–æ—à–µ–Ω–∏—è
    subscription: Mapped[Optional["UserSubscription"]] = relationship(back_populates="user", uselist=False)
    usage: Mapped[Optional["Usage"]] = relationship(back_populates="user", uselist=False)

class UserSubscription(Base):
    __tablename__ = "user_subscriptions"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), unique=True)
    plan_code: Mapped[Optional[str]] = mapped_column(String(64))     # None –æ–∑–Ω–∞—á–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é
    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    is_trial: Mapped[bool] = mapped_column(Boolean, default=True)

    user: Mapped["User"] = relationship(back_populates="subscription")

class Usage(Base):
    __tablename__ = "usage"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), unique=True)
    used_requests: Mapped[int] = mapped_column(Integer, default=0)
    used_images: Mapped[int] = mapped_column(Integer, default=0)

    user: Mapped["User"] = relationship(back_populates="usage")

class Payment(Base):
    __tablename__ = "payments"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(Integer, index=True)
    provider: Mapped[str] = mapped_column(String(64))
    provider_payment_id: Mapped[str] = mapped_column(String(128), index=True)
    plan_code: Mapped[str] = mapped_column(String(64))
    amount_rub: Mapped[int] = mapped_column(Integer)
    status: Mapped[str] = mapped_column(String(32), default="pending")  # pending/succeeded/canceled
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())

class ChatSession(Base):
    __tablename__ = "chat_sessions"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(Integer, index=True)
    title: Mapped[str] = mapped_column(String(255))
    mode: Mapped[str] = mapped_column(String(32), default="assistant")
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)

class Message(Base):
    __tablename__ = "messages"
    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    session_id: Mapped[int] = mapped_column(ForeignKey("chat_sessions.id"), index=True)
    role: Mapped[str] = mapped_column(String(32))  # user|assistant|system
    content: Mapped[str] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())


============================================================

payments/base.py:
========================================
from __future__ import annotations
from typing import Protocol

class PaymentProvider(Protocol):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø–ª–∞—Ç—ë–∂–Ω–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞."""
    async def create_invoice(self, user_id: int, plan_code: str, amount_rub: int, description: str) -> str:
        """–°–æ–∑–¥–∞–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç URL (redirect)."""
        ...

    # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ/–≤–µ–±—Ö—É–∫ ‚Äî —Ä–µ–∞–ª–∏–∑—É–µ—Ç—Å—è –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –≤–µ–±—Ö—É–∫–∞ (webhooks.py),
    # –∫–æ—Ç–æ—Ä—ã–π –≤—ã–∑—ã–≤–∞–µ—Ç services.subscriptions.activate_paid_plan(...)


============================================================

payments/mock.py:
========================================
from __future__ import annotations
from payments.base import PaymentProvider

class MockPaymentProvider(PaymentProvider):
    async def create_invoice(self, user_id: int, plan_code: str, amount_rub: int, description: str) -> str:
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–µ–π–∫–æ–≤—É—é —Å—Å—ã–ª–∫—É
        return f"https://example.com/pay?user={user_id}&plan={plan_code}&sum={amount_rub}"


============================================================

payments/yoomoney.py:
========================================
from __future__ import annotations

import requests
from config import cfg
from yookassa import Configuration, Payment as YooPayment
import uuid

import logging

logger = logging.getLogger(__name__)


class YooMoneyProvider:
    """–ÆKassa —Å —Ä—É—á–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å—Ç–∞—Ç—É—Å–∞ (–±–µ–∑ –≤–µ–±—Ö—É–∫–æ–≤)."""

    def __init__(self):
        Configuration.account_id = cfg.yookassa_shop_id
        Configuration.secret_key = cfg.yookassa_secret_key
        self.email = cfg.yookassa_invoice_email

    async def create_invoice(self, user_id: int, plan_code: str, amount_rub: int, description: str) -> str:
        """–°–æ–∑–¥–∞–µ—Ç –ø–ª–∞—Ç—ë–∂ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç redirect URL"""
        idempotence_key = str(uuid.uuid4())
        try:
            payment = YooPayment.create({
                "amount": {
                    "value": f"{amount_rub:.2f}",
                    "currency": "RUB"
                },
                "confirmation": {
                    "type": "redirect",
                    "return_url": "https://yoomoney.ru"
                },
                "capture": True,
                "description": description or f"–ü–ª–∞–Ω {plan_code}",
                "receipt": {
                    "customer": {
                        "email": self.email,
                    },
                    "items": [
                        {
                            "description": description,
                            "quantity": "1.00",
                            "amount": {
                                "value": f"{amount_rub:.2f}",
                                "currency": "RUB"
                            },
                            "vat_code": "1",
                            "payment_mode": "full_payment",
                            "payment_subject": "commodity",
                        },
                    ]
                },
                "metadata": {
                    "user_id": str(user_id),
                    "plan_code": plan_code
                }
            }, idempotence_key)
        except requests.exceptions.HTTPError as e:
            logger.error(f"[YooKassa] –û—à–∏–±–∫–∞ HTTP: {e.response.text}")
            raise
        return payment.confirmation.confirmation_url

    async def check_status(self, payment_id: str) -> str:
        payment = YooPayment.find_one(payment_id)
        return payment.status


============================================================

providers/base.py:
========================================
from __future__ import annotations
from typing import Protocol, Any, Sequence

class ChatProvider(Protocol):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —á–∞—Ç–∞."""
    async def chat(self, messages: Sequence[dict[str, str]], max_tokens: int, temperature: float = 0.7) -> str: ...

class ImageProvider(Protocol):
    """–ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π."""
    async def generate(self, prompt: str) -> bytes: ...
    async def edit(self, image_bytes: bytes, instruction: str) -> bytes: ...
    async def add_people(self, image_bytes: bytes, description: str) -> bytes: ...
    async def celebrity_selfie(self, image_bytes: bytes, celebrity_name: str, style: str | None = None) -> bytes: ...


============================================================

providers/openai_provider.py:
========================================
from __future__ import annotations
from typing import Sequence, AsyncGenerator
from openai import AsyncOpenAI
from config import cfg
import httpx


class OpenAIChatProvider:
    """OpenAI GPT —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ø–æ—Ç–æ–∫–æ–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞ –∏ –∫–∞—Å—Ç–æ–º–Ω—ã–º httpx-–∫–ª–∏–µ–Ω—Ç–æ–º."""

    def __init__(self, model: str = "gpt-4o"):
        self.model = model
        self.http_client = httpx.AsyncClient(timeout=httpx.Timeout(60.0, connect=10.0))
        self.client = AsyncOpenAI(
            api_key=cfg.openai_api_key,
            base_url=cfg.openai_api_base,
            http_client=self.http_client
        )

    async def stream_chat(
            self, messages: Sequence[dict[str, str]], max_tokens: int = 800, temperature: float = 0.7
    ) -> AsyncGenerator[str, None]:
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Å—Ç—Ä–∏–º–∏–Ω–≥ OpenAI GPT-4o."""
        async with self.client.chat.completions.stream(
                model=self.model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
        ) as stream:
            async for event in stream:
                if event.type == "message.delta":
                    delta = event.delta.content or ""
                    if delta:
                        yield delta


class OpenAIImageProvider:
    """–ü—Ä–æ–≤–∞–π–¥–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ DALL-E —Å –∫–∞—Å—Ç–æ–º–Ω—ã–º httpx-–∫–ª–∏–µ–Ω—Ç–æ–º."""

    def __init__(self, model: str = "dall-e-3"):  # ‚Üê –ò–ó–ú–ï–ù–ò–¢–ï –ó–î–ï–°–¨
        self.model = model
        self.http_client = httpx.AsyncClient(timeout=httpx.Timeout(120.0, connect=10.0))
        self.client = AsyncOpenAI(
            api_key=cfg.openai_api_key,
            base_url=cfg.openai_api_base,
            http_client=self.http_client,
        )

    async def generate(self, prompt: str) -> bytes:
        import base64
        try:
            response = await self.client.images.generate(
                model=self.model,
                prompt=prompt,
                size="1024x1024",
                n=1,
                response_format="b64_json"  # ‚Üê –î–û–ë–ê–í–¨–¢–ï –≠–¢–û
            )
            b64 = response.data[0].b64_json
            return base64.b64decode(b64)
        except Exception as e:
            print(f"OpenAI API Error: {e}")
            raise

    async def edit(self, image_bytes: bytes, instruction: str) -> bytes:
        prompt = f"–û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏: {instruction}"
        return await self.generate(prompt)

    async def add_people(self, image_bytes: bytes, description: str) -> bytes:
        prompt = f"–ù–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–æ—Ç–æ, –¥–æ–±–∞–≤—å –ª—é–¥–µ–π: {description}. –°–æ—Ö—Ä–∞–Ω–∏ —Å—Ç–∏–ª—å –∏ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç—å."
        return await self.generate(prompt)

    async def celebrity_selfie(self, image_bytes: bytes, celebrity_name: str, style: str | None = None) -> bytes:
        # –î–ª—è DALL-E –Ω–∞–º –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        prompt = f"–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–µ —Å–µ–ª—Ñ–∏ –¥–≤—É—Ö –ª—é–¥–µ–π. –û–¥–∏–Ω –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ {celebrity_name}, –≤—Ç–æ—Ä–æ–π - –æ–±—ã—á–Ω—ã–π —á–µ–ª–æ–≤–µ–∫. {style or ''} –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –¥–æ–ª–∂–Ω–∞ –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–µ–µ —Å–µ–ª—Ñ–∏, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ, –≤—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ."
        return await self.generate(prompt)

============================================================

queue_bg.py:
========================================
from __future__ import annotations
import asyncio
from typing import Callable, Awaitable, Any

class AsyncWorkerPool:
    """–ü—Ä–æ—Å—Ç–æ–π –ø—É–ª –≤–æ—Ä–∫–µ—Ä–æ–≤. –ö–ª–∞–¥–µ–º –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥—å ‚Äî –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –≤ —Ñ–æ–Ω–µ."""
    def __init__(self, workers: int):
        self.queue: asyncio.Queue[Callable[[], Awaitable[Any]]] = asyncio.Queue()
        self.workers = workers
        self._tasks: list[asyncio.Task] = []

    async def start(self):
        for _ in range(self.workers):
            self._tasks.append(asyncio.create_task(self._worker()))

    async def _worker(self):
        while True:
            job = await self.queue.get()
            try:
                await job()
            except Exception:
                # –ª–æ–≥–∏—Ä—É–µ–º/–º–µ—Ç—Ä–∏–∫–∏ ‚Äî –æ–ø—É—â–µ–Ω–æ
                pass
            finally:
                self.queue.task_done()

    async def submit(self, coro_factory: Callable[[], Awaitable[Any]]):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –∑–∞–¥–∞—á—É (–ª–µ–Ω–∏–≤—É—é —Ñ–∞–±—Ä–∏–∫—É –∫–æ—Ä—É—Ç–∏–Ω—ã) –≤ –æ—á–µ—Ä–µ–¥—å."""
        await self.queue.put(coro_factory)

    async def stop(self):
        for t in self._tasks:
            t.cancel()


============================================================

router_admin.py:
========================================
from __future__ import annotations

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message as TgMessage, CallbackQuery
from sqlalchemy import func
from sqlalchemy import select, update

from config import cfg
from db import AsyncSessionMaker
from keyboards import admin_menu
from models import Payment
from models import User
from payments.yoomoney import YooMoneyProvider
from services.subscriptions import activate_paid_plan

router = Router()

def is_admin(user_id: int) -> bool:
    return user_id in cfg.admin_ids

@router.message(Command("admin"))
async def admin_entry(m: TgMessage):
    if not is_admin(m.from_user.id):
        return
    await m.answer("–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:", reply_markup=admin_menu())

@router.callback_query(F.data == "admin:users")
async def admin_users(cq: CallbackQuery):
    if not is_admin(cq.from_user.id): return
    async with AsyncSessionMaker() as session:
        total = await session.scalar(select(func.count()).select_from(User))
    await cq.message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total}")
    await cq.answer()

@router.callback_query(F.data == "admin:broadcast")
async def admin_broadcast(cq: CallbackQuery):
    if not is_admin(cq.from_user.id): return
    await cq.message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
    await cq.answer()

@router.message(Command("check_payments"))
async def check_payments(m: TgMessage):
    if not is_admin(m.from_user.id):
        return
    provider = YooMoneyProvider()
    async with AsyncSessionMaker() as session:
        payments = (await session.execute(
            select(Payment).where(Payment.status == "pending")
        )).scalars().all()
        for p in payments:
            status = await provider.check_status(p.provider_payment_id)
            if status == "succeeded":
                await activate_paid_plan(session, p.user_id, p.plan_code)
                await session.execute(update(Payment).where(Payment.id == p.id).values(status="succeeded"))
        await session.commit()
    await m.answer("‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")


============================================================

router_public.py:
========================================
from __future__ import annotations

from datetime import datetime, timezone

from aiogram import Router, F
from aiogram.filters import Command, CommandStart
from aiogram.types import Message as TgMessage, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from sqlalchemy import select
from sqlalchemy import update
from aiogram.types import CallbackQuery, User, Chat

from config import cfg
from db import AsyncSessionMaker
from keyboards import plan_buy_keyboard
from keyboards import top_panel, keyboards_for_modes
from models import (
    User,
    ChatSession,
    UserSubscription,
    Usage,
)
from payments.yoomoney import YooMoneyProvider
from queue_bg import AsyncWorkerPool
from services.chat import ChatService
from services.images import ImageService
from services.subscriptions import ensure_user, get_limits
from services.usage import can_spend_request, spend_request, can_spend_image, spend_image
from services.subscriptions import has_active_subscription
from utils import store_message, get_history, trim_messages

router = Router()

# –ü—É–ª—ã —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
chat_pool = AsyncWorkerPool(cfg.workers_chat)
img_pool = AsyncWorkerPool(cfg.workers_images)


@router.startup()
async def _startup(bot):
    """–ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤—ã—Ö –ø—É–ª–æ–≤ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –±–æ—Ç–∞."""
    await chat_pool.start()
    await img_pool.start()


@router.shutdown()
async def _shutdown(bot):
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–æ–Ω–æ–≤—ã—Ö –ø—É–ª–æ–≤ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã."""
    await chat_pool.stop()
    await img_pool.stop()


async def _render_status_line(session, user_id: int) -> str:
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    now = datetime.now(timezone.utc)

    expires_at = None
    if sub and sub.expires_at:
        # –µ—Å–ª–∏ –¥–∞—Ç–∞ –±–µ–∑ —Ç–∞–π–º–∑–æ–Ω—ã ‚Äî —Å—á–∏—Ç–∞–µ–º –µ—ë UTC
        expires_at = sub.expires_at
        if expires_at.tzinfo is None:
            expires_at = expires_at.replace(tzinfo=timezone.utc)

    if not sub or not expires_at or expires_at <= now:
        status = "üî¥ –ù–µ–∞–∫—Ç–∏–≤–Ω–∞"
        expires_str = "‚Äî"
        plan_name = "–ü—Ä–æ–±–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∏—Å—Ç—ë–∫" if (sub and sub.is_trial) else "–ù–µ—Ç"
        limits = "–ó–∞–ø—Ä–æ—Å—ã: 0 / –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: 0"
    else:
        plan_code = sub.plan_code or "trial"
        plan_conf = cfg.plans.get(plan_code)
        status = "üü¢ –ê–∫—Ç–∏–≤–Ω–∞"
        expires_str = expires_at.astimezone().strftime("%d.%m.%Y %H:%M")
        if sub.is_trial:
            plan_name = "Trial"
            max_req, max_img, _ = cfg.trial_max_requests, cfg.trial_max_images, 4000
        else:
            plan_name = plan_conf.title if plan_conf else plan_code
            max_req = plan_conf.max_requests
            max_img = plan_conf.max_image_generations
        ur = usage.used_requests if usage else 0
        ui = usage.used_images if usage else 0
        limits = f"–ó–∞–ø—Ä–æ—Å—ã: {('‚àû' if max_req is None else f'{ur}/{max_req}')}, " \
                 f"–ò–∑–æ–±—Ä.: {('‚àû' if max_img is None else f'{ui}/{max_img}')}"

    text = f"<b>–ü–æ–¥–ø–∏—Å–∫–∞:</b> {status}\n" \
                f"<b>–¢–∞—Ä–∏—Ñ:</b> {plan_name}\n"
    if expires_str:
        text += f"<b>–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ:</b> {expires_str}\n"
        text += f"<b>–õ–∏–º–∏—Ç—ã:</b> {limits}"

    return text


@router.message(CommandStart())
async def start(m: TgMessage):
    ref_code = None
    if m.text and " " in m.text:
        ref_code = m.text.split(" ", 1)[1].strip()

    async with AsyncSessionMaker() as session:
        user = await ensure_user(session, m.from_user.id, m.from_user.username,
                                 m.from_user.first_name, m.from_user.last_name, ref_code)
        status = await _render_status_line(session, m.from_user.id)

    me = await m.bot.get_me()  # ‚Üê –≤–æ—Ç –∑–¥–µ—Å—å –ø–æ–ª—É—á–∞–µ–º –∏–º—è –±–æ—Ç–∞
    await m.answer(
        status,
        reply_markup=top_panel(me.username, user.referral_code)  # ‚Üê –ø–µ—Ä–µ–¥–∞—ë–º –µ–≥–æ —Å—é–¥–∞
    )


@router.message(Command("mode"))
async def cmd_mode(m: TgMessage):
    await m.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º:", reply_markup=keyboards_for_modes())


@router.message(Command("subscription"))
async def cmd_subscription(m: TgMessage):
    await show_subscription_panel(m)

@router.message(Command("help"))
async def cmd_help(m: TgMessage):
    text = (
        "‚ÑπÔ∏è <b>–ü–æ–º–æ—â—å</b>\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "‚Ä¢ /start ‚Äî –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
        "‚Ä¢ /mode ‚Äî –≤—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞\n"
        "‚Ä¢ /subscription ‚Äî –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ\n"
        "‚Ä¢ /new ‚Äî –Ω–æ–≤—ã–π —á–∞—Ç\n\n"
        "–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, –∏ –±–æ—Ç –æ—Ç–≤–µ—Ç–∏—Ç –≤–∞–º ü§ñ"
    )
    await m.answer(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="panel:main")]
    ]))

@router.message(Command("new"))
async def cmd_new_chat(m: TgMessage):
    """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —á–∞—Ç–∞"""
    async with AsyncSessionMaker() as session:
        # –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —á–∞—Ç—ã
        await session.execute(update(ChatSession).where(
            ChatSession.user_id == m.from_user.id,
            ChatSession.is_active == True
        ).values(is_active=False))

        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —á–∞—Ç
        new_session = ChatSession(
            user_id=m.from_user.id,
            title="–ù–æ–≤—ã–π —á–∞—Ç",
            mode="assistant",
            is_active=True
        )
        session.add(new_session)
        await session.commit()

    await m.answer("‚úÖ –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —á–∞—Ç. –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è.")

@router.message(Command("admin"))
async def cmd_admin(m: TgMessage):
    if m.from_user.id not in cfg.admin_ids:
        await m.answer("üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.")
        return

    await m.answer(
        "üõ° <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n"
        "1Ô∏è‚É£ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n"
        "2Ô∏è‚É£ –†–∞—Å—Å—ã–ª–∫–∏\n"
        "3Ô∏è‚É£ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π\n\n"
        "‚öôÔ∏è –î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="panel:main")]
        ])
    )


@router.callback_query(F.data == "panel:mode")
async def panel_mode(cq: CallbackQuery):
    await cq.message.edit_reply_markup(reply_markup=keyboards_for_modes())
    await cq.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º")


@router.callback_query(F.data == "panel:help")
async def panel_help(cq: CallbackQuery):
    text = (
        "‚ÑπÔ∏è <b>–ü–æ–º–æ—â—å</b>\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "‚Ä¢ /start ‚Äî –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
        "‚Ä¢ /new ‚Äî –Ω–æ–≤—ã–π —á–∞—Ç\n"
        "‚Ä¢ /mode ‚Äî –≤—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º\n"
        "‚Ä¢ /subscription ‚Äî –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ\n"
        "‚Ä¢ –ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç ‚Äî –∏ –ø–æ–ª—É—á–∏—Ç–µ –æ—Ç–≤–µ—Ç\n\n"
        "–ü–æ–¥–¥–µ—Ä–∂–∫–∞: @your_support_username"
    )
    await cq.message.edit_text(text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="panel:main")]
    ]))
    await cq.answer()


@router.callback_query(F.data == "panel:admin")
async def panel_admin(cq: CallbackQuery):
    if cq.from_user.id not in cfg.admin_ids:
        await cq.answer("üö´ –ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞", show_alert=True)
        return
    await cq.message.edit_text(
        "üõ° <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n–§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="panel:main")]
        ])
    )
    await cq.answer()


@router.callback_query(F.data.startswith("mode:"))
async def switch_mode(cq: CallbackQuery):
    mode = cq.data.split(":", 1)[1]
    if mode not in cfg.modes:
        await cq.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–∂–∏–º")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ —Ä–µ–∂–∏–º—É
    async with AsyncSessionMaker() as session:
        has_access = await has_active_subscription(session, cq.from_user.id)

        if not has_access:
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–∫–Ω–æ —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ–º –ø–æ–¥–ø–∏—Å–∫–∏
            text = (
                f"üö´ <b>–î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω</b>\n\n"
                f"üíé <b>–û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É</b> —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º —Ñ—É–Ω–∫—Ü–∏—è–º:"
            )
            await cq.message.edit_text(text)
            await cq.answer()

            await show_subs(cq, False)

            return

    async with AsyncSessionMaker() as session:
        # —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é —á–∞—Ç–∞ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ
        res = await session.execute(select(ChatSession).where(
            ChatSession.user_id == cq.from_user.id, ChatSession.is_active == True))
        active = res.scalars().first()
        if active:
            active.is_active = False
        session.add(ChatSession(user_id=cq.from_user.id, title=f"{mode.capitalize()} —á–∞—Ç", mode=mode, is_active=True))
        await session.commit()
    await cq.message.answer(f"–†–µ–∂–∏–º –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω: {mode}")
    await cq.answer()


def format_plan_info(code: str) -> str:
    plan = cfg.plans[code]
    limits = []
    limits.append("–ó–∞–ø—Ä–æ—Å—ã: ‚àû" if plan.max_requests is None else f"–ó–∞–ø—Ä–æ—Å—ã: –¥–æ {plan.max_requests}")
    limits.append(
        "–ì–µ–Ω–µ—Ä–∞—Ü–∏–∏: ‚àû" if plan.max_image_generations is None else f"–ì–µ–Ω–µ—Ä–∞—Ü–∏–∏: –¥–æ {plan.max_image_generations}")
    limits.append(f"–î–ª–∏–Ω–∞ –∑–∞–ø—Ä–æ—Å–∞: –¥–æ {plan.max_text_len} —Å–∏–º–≤–æ–ª–æ–≤")
    return (f"<b>{plan.title}</b>\n"
            f"–°—Ç–æ–∏–º–æ—Å—Ç—å: <b>{plan.price_rub} ‚ÇΩ</b> / {plan.duration_days} –¥–Ω–µ–π\n"
            f"{' ‚Ä¢ '.join(limits)}")


@router.callback_query(F.data == "subs:show")
async def show_subs(cq: CallbackQuery, is_edit: bool = True):
    text = (
        "üí≥ <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏</b>\n\n"
        f"{format_plan_info('pro_lite')}\n\n"
        f"{format_plan_info('pro_plus')}\n\n"
        f"{format_plan_info('pro_premium')}\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π —Ç–∞—Ä–∏—Ñ –¥–ª—è –æ–ø–ª–∞—Ç—ã."
    )
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ö—É–ø–∏—Ç—å Pro Lite", callback_data="buy:pro_lite")],
        [InlineKeyboardButton(text="–ö—É–ø–∏—Ç—å Pro Plus", callback_data="buy:pro_plus")],
        [InlineKeyboardButton(text="–ö—É–ø–∏—Ç—å Pro Premium", callback_data="buy:pro_premium")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="panel:main")],
    ])
    if is_edit:
        await cq.message.edit_text(text=text, reply_markup=kb)
        await cq.answer()
    else:
        await cq.message.answer(text=text, reply_markup=kb)


@router.callback_query(F.data.startswith("buy:"))
async def buy(cq: CallbackQuery):
    plan = cq.data.split(":", 1)[1]
    plan_conf = cfg.plans[plan]
    provider = YooMoneyProvider() if cfg.payment_provider == "yoomoney" else None
    description = f"–û–ø–ª–∞—Ç–∞ –ø–ª–∞–Ω–∞ {plan_conf.title}"

    # —Å–æ–∑–¥–∞–µ–º –ø–ª–∞—Ç—ë–∂
    pay_url = await provider.create_invoice(cq.from_user.id, plan, plan_conf.price_rub, description)

    # –∫—Ä–∞—Å–∏–≤—ã–π —Ç–µ–∫—Å—Ç + –∫—Ä–∞—Å–∏–≤–∞—è –∫–Ω–æ–ø–∫–∞
    text = (
        f"üßæ <b>–°—á—ë—Ç –Ω–∞ –æ–ø–ª–∞—Ç—É</b>\n\n"
        f"<b>–¢–∞—Ä–∏—Ñ:</b> {plan_conf.title}\n"
        f"<b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> {plan_conf.price_rub} ‚ÇΩ –∑–∞ {plan_conf.duration_days} –¥–Ω–µ–π\n"
        f"<b>–ß—Ç–æ –≤—Ö–æ–¥–∏—Ç:</b>\n"
        f"‚Ä¢ –ó–∞–ø—Ä–æ—Å—ã: {'‚àû' if plan_conf.max_requests is None else plan_conf.max_requests}\n"
        f"‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {'‚àû' if plan_conf.max_image_generations is None else plan_conf.max_image_generations}\n"
        f"‚Ä¢ –î–ª–∏–Ω–∞ –∑–∞–ø—Ä–æ—Å–∞: –¥–æ {plan_conf.max_text_len} —Å–∏–º–≤–æ–ª–æ–≤\n\n"
        f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ üëá"
    )
    await cq.message.answer(text, reply_markup=plan_buy_keyboard(plan, pay_url))
    await cq.answer()


@router.message(F.photo)
async def on_photo(m: TgMessage):
    """–ü—Ä–∏–Ω–∏–º–∞–µ–º —Ñ–æ—Ç–æ. –†–∞–±–æ—Ç–∞–µ–º –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ: editor/add_people/celebrity_selfie."""
    file_id = m.photo[-1].file_id
    mode = "editor"
    async with AsyncSessionMaker() as session:
        # —É–∑–Ω–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é –∏ –ª–∏–º–∏—Ç—ã
        res = await session.execute(
            select(ChatSession).where(ChatSession.user_id == m.from_user.id, ChatSession.is_active == True))
        chat_sess = res.scalars().first()
        if chat_sess:
            mode = chat_sess.mode
        max_req, max_img, max_text_len = await get_limits(session, m.from_user.id)
        if not await can_spend_image(session, m.from_user.id):
            await m.answer("–õ–∏–º–∏—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω. –û—Ñ–æ—Ä–º–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –∏–ª–∏ –ø–æ–¥–æ–∂–¥–∏—Ç–µ –ø—Ä–æ–¥–ª–µ–Ω–∏—è.")
            return

    # –ø–æ–¥–≥—Ä—É–∂–∞–µ–º bytes —Ñ–æ—Ç–æ
    photo_file = await m.bot.get_file(file_id)
    photo_bytes = await m.bot.download_file(photo_file.file_path)

    img_service = ImageService()

    # –ó–∞–¥–∞—á–∞ –≤ —Ñ–æ–Ω–µ
    async def job():
        new_img: bytes | None = None
        error: str | None = None
        if mode == "editor":
            instruction = m.caption or "–°–ª–µ–≥–∫–∞ —É–ª—É—á—à–∏—Ç—å –∫–∞—á–µ—Å—Ç–≤–æ –∏ —Ü–≤–µ—Ç."
            new_img, error = await img_service.edit(photo_bytes.read(), instruction)
        elif mode == "add_people":
            desc = m.caption or "–î–æ–±–∞–≤–∏—Ç—å –¥–≤—É—Ö –ª—é–¥–µ–π –Ω–∞ –∑–∞–¥–Ω–∏–π –ø–ª–∞–Ω, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è."
            new_img, error = await img_service.add_people(photo_bytes.read(), desc)
        elif mode == "celebrity_selfie":
            celeb = (m.caption or "–ò–∑–≤–µ—Å—Ç–Ω–∞—è –ª–∏—á–Ω–æ—Å—Ç—å").strip()
            new_img, error = await img_service.celebrity_selfie(photo_bytes.read(), celeb)
        else:
            new_img, error = await img_service.edit(photo_bytes.read(), "–£–ª—É—á—à–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.")

        if error:
            await m.answer(f"‚ùóÔ∏è {error}")
            return

        if new_img:
            await m.answer_photo(new_img, caption=f"–ì–æ—Ç–æ–≤–æ! –†–µ–∂–∏–º: {mode}")
            async with AsyncSessionMaker() as session:
                await spend_image(session, m.from_user.id)

    await img_pool.submit(job)


@router.message(F.text & ~F.via_bot)
async def on_text(m: TgMessage):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–±—ã—á–Ω—ã–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ç–µ–∫—É—â–µ–º —Ä–µ–∂–∏–º–µ."""
    text = m.text.strip()
    user_id = m.from_user.id

    # —Ä–µ–∂–∏–º (–Ω–∞–ø—Ä–∏–º–µ—Ä assistant / image) ‚Äî –ø–æ–ª—É—á–∞–µ–º –∏–∑ –±–∞–∑—ã, –Ω–æ –ø–æ–∫–∞ –ø—É—Å—Ç—å –¥–µ—Ñ–æ–ª—Ç
    mode = "assistant"

    if mode == "assistant":
        chat_service = ChatService()
        await chat_service.handle_user_message(text, m.bot, m.chat.id)
    else:
        await m.answer("‚öôÔ∏è –î—Ä—É–≥–∏–µ —Ä–µ–∂–∏–º—ã –ø–æ–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.")


@router.callback_query(F.data == "chat:new")
async def new_chat(cq: CallbackQuery):
    async with AsyncSessionMaker() as session:
        # –¥–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –≤—Å–µ –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π assistant
        await session.execute(update(ChatSession).where(
            ChatSession.user_id == cq.from_user.id, ChatSession.is_active == True
        ).values(is_active=False))
        session.add(ChatSession(user_id=cq.from_user.id, title="–ù–æ–≤—ã–π —á–∞—Ç", mode="assistant", is_active=True))
        await session.commit()
    await cq.message.answer("–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π —á–∞—Ç. –ü–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
    await cq.answer()


@router.callback_query(F.data == "chat:list")
async def chat_list(cq: CallbackQuery):
    PAGE_SIZE = 10
    page = 1
    if cq.message and cq.message.reply_markup:
        # –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–∞–≥–∏–Ω–∞—Ü–∏—é —á–µ—Ä–µ–∑ callback_data –≤–∏–¥–∞ chat:list:2
        pass
    async with AsyncSessionMaker() as session:
        rows = (await session.execute(
            select(ChatSession).where(ChatSession.user_id == cq.from_user.id).order_by(ChatSession.id.desc()).limit(100)
        )).scalars().all()

    if not rows:
        await cq.message.answer("–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö —á–∞—Ç–æ–≤.")
        await cq.answer()
        return

    lines = []
    for s in rows[:PAGE_SIZE]:
        mark = "üü¢" if s.is_active else "‚ö™Ô∏è"
        lines.append(f"{mark} <b>{s.title}</b> ‚Äî {s.mode} (#{s.id})")
    text = "üìÅ <b>–í–∞—à–∏ —á–∞—Ç—ã</b>\n" + "\n".join(lines)
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Ä–≤—ã–π", callback_data=f"chat:activate:{rows[0].id}")],
        [InlineKeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π", callback_data="chat:new")]
    ])
    await cq.message.answer(text, reply_markup=kb)
    await cq.answer()


@router.callback_query(F.data.startswith("chat:activate:"))
async def chat_activate(cq: CallbackQuery):
    sess_id = int(cq.data.split(":")[-1])
    async with AsyncSessionMaker() as session:
        await session.execute(update(ChatSession).where(
            ChatSession.user_id == cq.from_user.id, ChatSession.is_active == True
        ).values(is_active=False))
        await session.execute(update(ChatSession).where(
            ChatSession.id == sess_id, ChatSession.user_id == cq.from_user.id
        ).values(is_active=True))
        await session.commit()
    await cq.message.answer(f"‚úîÔ∏è –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —á–∞—Ç #{sess_id}")
    await cq.answer()


async def show_subscription_panel(m: TgMessage):
    async with AsyncSessionMaker() as session:
        status = await _render_status_line(session, m.from_user.id)
        user_row = (await session.execute(select(User).where(User.id == m.from_user.id))).scalars().first()
    me = await m.bot.get_me()
    await m.answer(status, reply_markup=top_panel(me.username, user_row.referral_code))


@router.callback_query(F.data == "panel:main")
async def panel_main(cq: CallbackQuery):
    async with AsyncSessionMaker() as session:
        status = await _render_status_line(session, cq.from_user.id)
        user_row = (await session.execute(
            select(User).where(User.id == cq.from_user.id)
        )).scalars().first()
    me = await cq.bot.get_me()
    await cq.message.edit_text(status, reply_markup=top_panel(me.username, user_row.referral_code))
    await cq.answer()

============================================================

services/chat.py:
========================================
from __future__ import annotations
from providers.openai_provider import OpenAIChatProvider
from services.safety import SafetyGuard

class ChatService:
    def __init__(self, provider=None):
        self.provider = provider or OpenAIChatProvider(model="gpt-4o")

    async def handle_user_message(self, message: str, bot, chat_id: int):
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫–æ–≤—ã–π –æ—Ç–≤–µ—Ç GPT."""
        sent = await bot.send_message(chat_id, "ü§î –î—É–º–∞—é‚Ä¶")
        full_text = ""
        async for delta in self.provider.stream_chat([{"role": "user", "content": message}]):
            full_text += delta
            try:
                await bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=sent.message_id,
                    text=f"üí¨ {full_text}"
                )
            except Exception:
                pass
        await bot.edit_message_text(
            chat_id=chat_id,
            message_id=sent.message_id,
            text=f"üí¨ {full_text}"
        )

============================================================

services/images.py:
========================================
from __future__ import annotations
from providers.openai_provider import OpenAIImageProvider
from services.safety import SafetyGuard, SafetyDecision


class ImageService:
    """–§–∞—Å–∞–¥ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π. –õ–µ–≥–∫–æ –∑–∞–º–µ–Ω–∏—Ç—å –ø—Ä–æ–≤–∞–π–¥–µ—Ä."""

    def __init__(self, provider: OpenAIImageProvider | None = None):
        self.provider = provider or OpenAIImageProvider()

    async def generate(self, prompt: str) -> tuple[bytes | None, str | None]:
        try:
            img = await self.provider.generate(prompt)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {str(e)}"

    async def edit(self, image_bytes: bytes, instruction: str) -> tuple[bytes | None, str | None]:
        try:
            img = await self.provider.edit(image_bytes, instruction)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {str(e)}"

    async def add_people(self, image_bytes: bytes, description: str) -> tuple[bytes | None, str | None]:
        try:
            img = await self.provider.add_people(image_bytes, description)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ª—é–¥–µ–π: {str(e)}"

    async def celebrity_selfie(self, image_bytes: bytes, celebrity_name: str, style: str | None = None) -> tuple[
        bytes | None, str | None]:
        # SafetyGate: –±–ª–æ–∫–∏—Ä—É–µ–º deepfake —Å–æ –∑–Ω–∞–º–µ–Ω–∏—Ç–æ—Å—Ç—è–º–∏
        dec: SafetyDecision = SafetyGuard.check_celebrity_selfie(celebrity_name)
        if not dec.allowed:
            return None, dec.reason or "–û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–ø—Ä–µ—â–µ–Ω–∞ –ø–æ–ª–∏—Ç–∏–∫–∞–º–∏."

        try:
            img = await self.provider.celebrity_selfie(image_bytes, celebrity_name, style)
            return img, None
        except Exception as e:
            return None, f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ–ª—Ñ–∏: {str(e)}"

============================================================

services/payments_monitor.py:
========================================
# services/payments_monitor.py
from __future__ import annotations
import asyncio
import logging
from sqlalchemy import select, update
from db import AsyncSessionMaker
from models import Payment, User
from payments.yoomoney import YooMoneyProvider
from services.subscriptions import activate_paid_plan
from services.referrals import apply_referral_bonus
from router_admin import is_admin

logger = logging.getLogger(__name__)


class PaymentMonitor:
    """–§–æ–Ω–æ–≤—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–ª–∞—Ç–µ–∂–µ–π."""

    def __init__(self, interval_min: float = 1):
        self.interval_min = interval_min
        self.running = False

    async def run_forever(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∫–∏."""
        self.running = True
        provider = YooMoneyProvider()
        logger.info(f"[PaymentMonitor] –ó–∞–ø—É—â–µ–Ω. –ò–Ω—Ç–µ—Ä–≤–∞–ª: {self.interval_min} –º–∏–Ω—É—Ç.")
        while self.running:
            try:
                await self.check_pending(provider)
            except Exception as e:
                logger.exception(f"[PaymentMonitor] –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}")
            await asyncio.sleep(self.interval_min * 60)

    async def stop(self):
        self.running = False

    async def check_pending(self, provider: YooMoneyProvider):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≤—Å–µ –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏."""
        async with AsyncSessionMaker() as session:
            payments = (await session.execute(
                select(Payment).where(Payment.status == "pending")
            )).scalars().all()

            if not payments:
                logger.info("[PaymentMonitor] –ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π.")
                return

            for p in payments:
                try:
                    status = await provider.check_status(p.provider_payment_id)
                    logger.info("–ü–ª–∞—Ç–µ–∂ " + p.provider_payment_id + ": " + p.user_id + " : " + status)
                    if is_admin(p.user_id):
                        logger.info("–ê–¥–º–∏–Ω—Å–∫–∏–π –ø–ª–∞—Ç–µ–∂ " + p.provider_payment_id + ": " + p.user_id)
                        status = "succeeded"
                except Exception as e:
                    logger.warning(f"[PaymentMonitor] –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —Å—Ç–∞—Ç—É—Å–∞ –¥–ª—è {p.id}: {e}")
                    continue

                if status == "succeeded":
                    logger.info(f"[PaymentMonitor] –ü–ª–∞—Ç–µ–∂ {p.id} ({p.plan_code}) –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω.")
                    await activate_paid_plan(session, p.user_id, p.plan_code)

                    # –ë–æ–Ω—É—Å –∑–∞ —Ä–µ—Ñ–µ—Ä–∞–ª–∫—É
                    user = await session.get(User, p.user_id)
                    if user and user.referred_by:
                        await apply_referral_bonus(session, user.referred_by)

                    await session.execute(update(Payment)
                                          .where(Payment.id == p.id)
                                          .values(status="succeeded"))
                    await session.commit()

                elif status in ("canceled", "expired"):
                    logger.info(f"[PaymentMonitor] –ü–ª–∞—Ç–µ–∂ {p.id} –æ—Ç–º–µ–Ω–µ–Ω ({status}).")
                    await session.execute(update(Payment)
                                          .where(Payment.id == p.id)
                                          .values(status=status))
                    await session.commit()


============================================================

services/referrals.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import timedelta, datetime
from config import cfg
from models import UserSubscription

async def apply_referral_bonus(session: AsyncSession, referrer_user_id: int) -> None:
    """–î–∞—Ä–∏–º —Ä–µ—Ñ–µ—Ä–µ—Ä—É +N –¥–Ω–µ–π –∫ —Ç–µ–∫—É—â–µ–π –ø–æ–¥–ø–∏—Å–∫–µ."""
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == referrer_user_id))
    now = datetime.now(datetime.now().astimezone().tzinfo)
    bonus = timedelta(days=cfg.referral_bonus_days)

    if not sub:
        sub = UserSubscription(user_id=referrer_user_id, is_trial=False, plan_code="pro_lite")
        session.add(sub)

    if sub.expires_at and sub.expires_at > now:
        sub.expires_at = sub.expires_at + bonus
    else:
        sub.expires_at = now + bonus

    await session.commit()


============================================================

services/safety.py:
========================================
from __future__ import annotations

class SafetyDecision:
    def __init__(self, allowed: bool, reason: str | None = None):
        self.allowed = allowed
        self.reason = reason

class SafetyGuard:
    """–ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞. –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –≤–Ω–µ–¥—Ä–∏—Ç—å —Å–≤–æ–∏ –ø—Ä–∞–≤–∏–ª–∞ –∏/–∏–ª–∏ –º–æ–¥–µ—Ä–∞—Ü–∏—é –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤."""
    BLOCKED_CELEBRITY_SELFIE = False  # –ø—Ä–∏–º–µ—Ä —Ñ–ª–∞–≥–∞ ‚Äî –¥–ª—è OpenAI –ª—É—á—à–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å deepfake —Å –ø—É–±–ª–∏—á–Ω—ã–º–∏ —Ñ–∏–≥—É—Ä–∞–º–∏

    @classmethod
    def check_celebrity_selfie(cls, celebrity_name: str) -> SafetyDecision:
        if cls.BLOCKED_CELEBRITY_SELFIE:
            return SafetyDecision(False, "–°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å —É—á–∞—Å—Ç–∏–µ–º –∑–Ω–∞–º–µ–Ω–∏—Ç–æ—Å—Ç–µ–π –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –ø–æ–ª–∏—Ç–∏–∫–∞–º–∏. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º.")
        return SafetyDecision(True)

    @classmethod
    def check_text_length(cls, text: str, max_len: int) -> SafetyDecision:
        if len(text) > max_len:
            return SafetyDecision(False, f"–ü—Ä–µ–≤—ã—à–µ–Ω–∞ –¥–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞ ({len(text)} > {max_len}). –£–∫–æ—Ä–æ—Ç–∏—Ç–µ –∑–∞–ø—Ä–æ—Å.")
        return SafetyDecision(True)


============================================================

services/subscriptions.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import datetime, timedelta, timezone
from config import cfg
from models import User, UserSubscription, Usage

async def ensure_user(session: AsyncSession, tg_user_id: int, username: str | None, first_name: str | None, last_name: str | None, referred_by_code: str | None = None) -> User:
    """–°–æ–∑–¥–∞—ë—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –ø–æ–¥–ø–∏—Å–∫—É trial –∏ usage –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—Ö–æ–¥–µ."""
    user = await session.scalar(select(User).where(User.id == tg_user_id))
    if user:
        return user

    # –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ—Ñ. –∫–æ–¥
    ref_code = f"ref{tg_user_id}"
    user = User(
        id=tg_user_id, username=username, first_name=first_name, last_name=last_name, referral_code=ref_code
    )
    session.add(user)
    await session.flush()

    # —Å–≤—è–∑—ã–≤–∞–µ–º —Ä–µ—Ñ–µ—Ä–∞
    if referred_by_code:
        referrer = await session.scalar(select(User).where(User.referral_code == referred_by_code))
        if referrer:
            user.referred_by = referrer.id

    # —Å–æ–∑–¥–∞–µ–º trial –ø–æ–¥–ø–∏—Å–∫—É
    sub = UserSubscription(
        user_id=user.id,
        plan_code=None,
        is_trial=True,
        expires_at=datetime.now(timezone.utc) + timedelta(days=cfg.trial_days),
    )
    session.add(sub)
    # usage
    usage = Usage(user_id=user.id, used_requests=0, used_images=0)
    session.add(usage)

    await session.commit()
    return user

async def has_active_subscription(session: AsyncSession, user_id: int) -> bool:
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    if not sub or not sub.expires_at:
        return False
    return sub.expires_at > datetime.now(datetime.now().astimezone().tzinfo).astimezone().replace(tzinfo=None)

async def get_limits(session: AsyncSession, user_id: int) -> tuple[int | None, int | None, int]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (max_requests, max_images, max_text_len) –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–ª–∞–Ω–∞/—Ç—Ä–∏–∞–ª–∞."""
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    if not sub:
        # –±–µ–∑ –ø–æ–¥–ø–∏—Å–∫–∏ ‚Äî –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞
        return (0, 0, 0)
    if sub.is_trial:
        return (cfg.trial_max_requests, cfg.trial_max_images, 4000)
    plan = cfg.plans.get(sub.plan_code or "", None)
    if not plan:
        return (0, 0, 0)
    return (plan.max_requests, plan.max_image_generations, plan.max_text_len)

async def activate_paid_plan(session: AsyncSession, user_id: int, plan_code: str) -> None:
    """–ê–∫—Ç–∏–≤–∞—Ü–∏—è –ø–ª–∞—Ç–Ω–æ–≥–æ –ø–ª–∞–Ω–∞ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã). –ü—Ä–æ–¥–ª–µ–≤–∞–µ—Ç –≤—Ä–µ–º—è –∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç usage."""
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    now = datetime.now(datetime.now().astimezone().tzinfo)
    if not sub:
        sub = UserSubscription(user_id=user_id)
        session.add(sub)

    plan = cfg.plans[plan_code]
    if sub.expires_at and sub.expires_at > now:
        sub.expires_at = sub.expires_at + timedelta(days=plan.duration_days)
    else:
        sub.expires_at = now + timedelta(days=plan.duration_days)
    sub.plan_code = plan_code
    sub.is_trial = False

    # –°–±—Ä–æ—Å usage –ø–æ–¥ –Ω–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    if usage:
        usage.used_requests = 0
        usage.used_images = 0

    await session.commit()


============================================================

services/usage.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models import Usage
from services.subscriptions import get_limits

async def can_spend_request(session: AsyncSession, user_id: int) -> bool:
    max_req, _, _ = await get_limits(session, user_id)
    if max_req is None:
        return True
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    return usage.used_requests < max_req

async def can_spend_image(session: AsyncSession, user_id: int) -> bool:
    _, max_img, _ = await get_limits(session, user_id)
    if max_img is None:
        return True
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    return usage.used_images < max_img

async def spend_request(session: AsyncSession, user_id: int) -> None:
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    usage.used_requests += 1
    await session.commit()

async def spend_image(session: AsyncSession, user_id: int) -> None:
    usage = await session.scalar(select(Usage).where(Usage.user_id == user_id))
    usage.used_images += 1
    await session.commit()


============================================================

utils.py:
========================================
from __future__ import annotations
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from models import User, UserSubscription, Usage, ChatSession, Message
from services.subscriptions import get_limits
from typing import Iterable

async def require_active_subscription(session: AsyncSession, user_id: int) -> bool:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –∏ –Ω–µ –∏—Å—Ç—ë–∫ trial."""
    sub = await session.scalar(select(UserSubscription).where(UserSubscription.user_id == user_id))
    if not sub or not sub.expires_at:
        return False
    return sub.expires_at.timestamp() > __import__("time").time()

async def store_message(session: AsyncSession, session_id: int, role: str, content: str) -> None:
    m = Message(session_id=session_id, role=role, content=content)
    session.add(m)
    await session.commit()

async def get_history(session: AsyncSession, session_id: int, limit: int = 30) -> list[dict[str, str]]:
    res = (await session.execute(
        select(Message).where(Message.session_id == session_id).order_by(Message.id.desc()).limit(limit)
    )).scalars().all()
    out: list[dict[str, str]] = [{"role": m.role, "content": m.content} for m in reversed(res)]
    return out

def trim_messages(tokens_est: int, messages: list[dict[str, str]], max_len: int) -> list[dict[str, str]]:
    """–ü—Ä–æ—Å—Ç–æ–µ —É—Å–µ—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ –¥–ª–∏–Ω–µ —Ç–µ–∫—Å—Ç–∞ (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)."""
    total = 0
    out: list[dict[str, str]] = []
    for m in reversed(messages):
        l = len(m.get("content", ""))
        if total + l > max_len:
            break
        out.append(m)
        total += l
    return list(reversed(out))


============================================================

