bot/__init__.py:
========================================


============================================================

bot/admin_handlers.py:
========================================
import asyncio
import logging
from datetime import datetime
from typing import Optional, Dict, Any

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import CallbackContext

import config
from base_handler import BaseHandler
from keyboards import BotKeyboards

logger = logging.getLogger(__name__)


class AdminHandlers(BaseHandler):
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏."""

    VALID_ROLES = ['admin', 'beta_tester', 'friend', 'regular_user', 'trial_user']

    async def _admin_precheck(self, update: Update, context: CallbackContext, user_id: int) -> bool:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è –∞–¥–º–∏–Ω-–∫–æ–º–∞–Ω–¥."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        if not self._is_admin(user_id):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ.")
            return False
        return True

    def _is_admin(self, user_id: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º."""
        return str(user_id) in config.roles.get('admin', [])

    async def _show_admin_panel(self, update: Update, context: CallbackContext) -> None:
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å."""
        text = "üõ†Ô∏è <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
        reply_markup = BotKeyboards.get_admin_keyboard()

        if update.message:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
        else:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

    async def admin_panel_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        await self._show_admin_panel(update, context)

    async def show_users_handle(self, update: Update, context: CallbackContext) -> None:
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        users = self.db.get_users_and_roles()

        if not users:
            await update.message.reply_text("üìù –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
            return

        text_lines = ["üë• <b>–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:</b>\n\n"]

        for i, user in enumerate(users[:50], 1):
            username = user.get('username', '–ù–µ—Ç username')
            first_name = user.get('first_name', '–ù–µ—Ç –∏–º–µ–Ω–∏')
            role = user.get('role', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')
            last_interaction = user.get('last_interaction', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')

            if isinstance(last_interaction, datetime):
                last_interaction = last_interaction.strftime("%d.%m.%Y %H:%M")

            text_lines.extend([
                f"{i}. ID: {user['_id']}\n",
                f"   üë§: {first_name} (@{username})\n",
                f"   üè∑Ô∏è: {role}\n",
                f"   ‚è∞: {last_interaction}\n\n"
            ])

        if len(users) > 50:
            text_lines.append(f"\n... –∏ –µ—â–µ {len(users) - 50} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")

        reply_markup = BotKeyboards.get_back_to_admin_keyboard()
        await update.message.reply_text(''.join(text_lines), parse_mode=ParseMode.HTML, reply_markup=reply_markup)

    async def _show_command_help(self, update: Update, command: str, help_text: str) -> None:
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø—Ä–∞–≤–∫—É –ø–æ –∫–æ–º–∞–Ω–¥–µ."""
        reply_markup = BotKeyboards.get_back_to_admin_keyboard()
        await update.message.reply_text(help_text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)

    async def edit_user_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        text = (
            "‚úèÔ∏è <b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
            "–î–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "<code>/edit_user USER_ID ROLE</code>\n\n"
            "–ü—Ä–∏–º–µ—Ä:\n"
            "<code>/edit_user 123456789 admin</code>\n\n"
            f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–æ–ª–∏: {', '.join(self.VALID_ROLES)}"
        )

        await self._show_command_help(update, "edit_user", text)

    async def broadcast_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–∞—Å—Å—ã–ª–∫—É."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        text = (
            "üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n"
            "–î–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "<code>/broadcast –¢–ï–ö–°–¢_–°–û–û–ë–©–ï–ù–ò–Ø</code>\n\n"
            "–ü—Ä–∏–º–µ—Ä:\n"
            "<code>/broadcast –í—Å–µ–º –ø—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞.</code>"
        )

        await self._show_command_help(update, "broadcast", text)

    async def get_user_data_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        text = (
            "üë§ <b>–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
            "–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "<code>/user_data USER_ID</code>\n\n"
            "–ü—Ä–∏–º–µ—Ä:\n"
            "<code>/user_data 123456789</code>\n\n"
            "–ò–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n"
            "<code>/user_data @username</code>"
        )

        await self._show_command_help(update, "user_data", text)

    async def handle_main_menu_back(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏."""
        user_id = update.message.from_user.id
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        reply_markup = await BotKeyboards.get_main_keyboard(user_id)
        await update.message.reply_text(
            "–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é...",
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )

    async def handle_admin_panel_back(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–æ–∑–≤—Ä–∞—Ç –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        await self._show_admin_panel(update, context)

    async def edit_user_command(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /edit_user."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        if not context.args or len(context.args) < 2:
            await update.message.reply_text(
                "‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /edit_user USER_ID ROLE\n"
                "–ü—Ä–∏–º–µ—Ä: /edit_user 123456789 admin"
            )
            return

        try:
            target_user_id = int(context.args[0])
            new_role = context.args[1]

            if not self.db.check_if_user_exists(target_user_id):
                await update.message.reply_text(f"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {target_user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                return

            if new_role not in self.VALID_ROLES:
                await update.message.reply_text(
                    f"‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å. –î–æ–ø—É—Å—Ç–∏–º—ã–µ —Ä–æ–ª–∏: {', '.join(self.VALID_ROLES)}"
                )
                return

            self.db.set_user_attribute(target_user_id, "role", new_role)
            await update.message.reply_text(
                f"‚úÖ –†–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_user_id} —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ '{new_role}'"
            )

        except ValueError:
            await update.message.reply_text("‚ùå ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º.")
        except Exception as e:
            logger.error(f"Error editing user: {e}")
            await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")

    async def broadcast_command(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /broadcast."""
        user_id = update.message.from_user.id

        if not await self._admin_precheck(update, context, user_id):
            return

        if not context.args:
            await update.message.reply_text(
                "‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /broadcast –¢–ï–ö–°–¢_–°–û–û–ë–©–ï–ù–ò–Ø\n"
                "–ü—Ä–∏–º–µ—Ä: /broadcast –í—Å–µ–º –ø—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞."
            )
            return

        message_text = ' '.join(context.args)

        confirmation_text = (
            f"üì¢ <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
            f"–¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è:\n{message_text}\n\n"
            f"–û—Ç–ø—Ä–∞–≤–∏—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º?"
        )

        keyboard = [
            [
                InlineKeyboardButton("‚úÖ –î–∞, –æ—Ç–ø—Ä–∞–≤–∏—Ç—å", callback_data=f"confirm_broadcast|{message_text}"),
                InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_broadcast")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(confirmation_text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)

    async def broadcast_confirmation_handler(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏."""
        query = update.callback_query
        await query.answer()

        user_id = query.from_user.id
        if not self._is_admin(user_id):
            await query.edit_message_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ.")
            return

        data = query.data

        if data == "cancel_broadcast":
            await query.edit_message_text("‚ùå –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
            return

        if data.startswith("confirm_broadcast|"):
            message_text = data.split("|", 1)[1]
            await query.edit_message_text("üîÑ –ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—Å—ã–ª–∫—É...")

            all_user_ids = self.db.get_all_user_ids()
            success_count = 0
            fail_count = 0

            for target_user_id in all_user_ids:
                try:
                    user_data = self.db.get_user_by_id(target_user_id)
                    if user_data and 'chat_id' in user_data:
                        await context.bot.send_message(
                            chat_id=user_data['chat_id'],
                            text=f"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:</b>\n\n{message_text}",
                            parse_mode=ParseMode.HTML
                        )
                        success_count += 1
                    else:
                        fail_count += 1
                except Exception as e:
                    logger.error(f"Error sending broadcast to {target_user_id}: {e}")
                    fail_count += 1

                await asyncio.sleep(0.1)

            result_text = (
                f"‚úÖ <b>–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞</b>\n\n"
                f"‚úÖ –£—Å–ø–µ—à–Ω–æ: {success_count}\n"
                f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å: {fail_count}\n"
                f"üìä –í—Å–µ–≥–æ: {len(all_user_ids)}"
            )

            await query.edit_message_text(result_text, parse_mode=ParseMode.HTML)

    async def get_user_data_command(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /user_data."""
        try:
            user = self._get_user_from_update(update)
            await self.register_user_if_not_exists(update, context, user)
            user_id = user.id

            if not self._is_admin(user_id):
                await self._send_reply(update, "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ.")
                return

            if not context.args:
                error_text = (
                    "‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.\n"
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /user_data USER_ID\n"
                    "–ü—Ä–∏–º–µ—Ä: /user_data 123456789"
                )
                await self._send_reply(update, error_text)
                return

            user_identifier = context.args[0]
            target_user = self._find_user_by_identifier(user_identifier)

            if not target_user:
                await self._send_reply(update, f"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å '{user_identifier}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
                return

            user_info = await self._format_user_details(target_user)
            await self._send_reply(update, user_info)

        except Exception as e:
            logger.error(f"Error getting user data: {e}")
            error_text = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."
            await self._send_reply(update, error_text)

    def _get_user_from_update(self, update: Update):
        """–ü–æ–ª—É—á–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ update."""
        if update.message:
            return update.message.from_user
        elif update.callback_query:
            return update.callback_query.from_user
        return None

    def _find_user_by_identifier(self, user_identifier: str) -> Optional[Dict[str, Any]]:
        """–ù–∞—Ö–æ–¥–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID –∏–ª–∏ username."""
        if user_identifier.startswith('@'):
            username = user_identifier[1:]
            return self.db.find_user_by_username(username)
        else:
            try:
                target_user_id = int(user_identifier)
                return self.db.get_user_by_id(target_user_id)
            except ValueError:
                return None

    async def _send_reply(self, update: Update, text: str, parse_mode: str = ParseMode.HTML) -> None:
        """–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞."""
        try:
            if update.message:
                await update.message.reply_text(text, parse_mode=parse_mode)
            elif update.callback_query:
                await update.callback_query.message.reply_text(text, parse_mode=parse_mode)
        except Exception as e:
            logger.error(f"Error sending reply: {e}")

    async def _format_user_details(self, user_data: Dict[str, Any]) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ."""
        user_id = user_data['_id']

        text_lines = [
            f"üë§ <b>–î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n",
            f"<b>ID:</b> <code>{user_id}</code>\n",
            f"<b>Username:</b> @{user_data.get('username', '–Ω–µ —É–∫–∞–∑–∞–Ω')}\n",
            f"<b>–ò–º—è:</b> {user_data.get('first_name', '–Ω–µ —É–∫–∞–∑–∞–Ω–æ')}\n",
            f"<b>–§–∞–º–∏–ª–∏—è:</b> {user_data.get('last_name', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}\n",
            f"<b>Chat ID:</b> <code>{user_data.get('chat_id', '–Ω–µ —É–∫–∞–∑–∞–Ω')}</code>\n",
            f"<b>–†–æ–ª—å:</b> {user_data.get('role', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}\n\n"
        ]

        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ
        subscription_info = self.db.get_user_subscription_info(user_id)
        if subscription_info["is_active"]:
            expires_at = subscription_info["expires_at"].strftime("%d.%m.%Y %H:%M")
            text_lines.extend([
                f"<b>–ü–æ–¥–ø–∏—Å–∫–∞:</b> {subscription_info['type']}\n",
                f"<b>–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ:</b> {expires_at}\n",
                f"<b>–ó–∞–ø—Ä–æ—Å–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {subscription_info['requests_used']}\n",
                f"<b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {subscription_info['images_used']}\n\n"
            ])
        else:
            text_lines.append("<b>–ü–æ–¥–ø–∏—Å–∫–∞:</b> –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞\n\n")

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        text_lines.append("<b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:</b>\n")

        n_used_tokens = user_data.get('n_used_tokens', {})
        if n_used_tokens:
            for model, tokens in n_used_tokens.items():
                input_tokens = tokens.get('n_input_tokens', 0)
                output_tokens = tokens.get('n_output_tokens', 0)
                text_lines.append(f"  {model}: {input_tokens} –≤–≤–æ–¥ / {output_tokens} –≤—ã–≤–æ–¥\n")
        else:
            text_lines.append("  –¢–æ–∫–µ–Ω—ã: –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏—Å—å\n")

        n_generated_images = user_data.get('n_generated_images', 0)
        text_lines.append(f"  –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {n_generated_images}\n")

        n_transcribed_seconds = user_data.get('n_transcribed_seconds', 0)
        text_lines.append(f"  –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ –∞—É–¥–∏–æ: {n_transcribed_seconds} —Å–µ–∫.\n\n")

        # –§–∏–Ω–∞–Ω—Å–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        financials = self.db.get_user_financials(user_id)
        text_lines.extend([
            "<b>–§–∏–Ω–∞–Ω—Å–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</b>\n",
            f"  –ë–∞–ª–∞–Ω—Å RUB: {user_data.get('rub_balance', 0)}‚ÇΩ\n",
            f"  –ë–∞–ª–∞–Ω—Å EUR: {user_data.get('euro_balance', 0)}‚Ç¨\n",
            f"  –í—Å–µ–≥–æ –ø–æ–ø–æ–ª–Ω–µ–Ω–æ: {financials.get('total_topup', 0)}‚ÇΩ\n",
            f"  –í—Å–µ–≥–æ –ø–æ—Ç—Ä–∞—á–µ–Ω–æ: {user_data.get('total_spent', 0)}‚ÇΩ\n",
            f"  –ü–æ–∂–µ—Ä—Ç–≤–æ–≤–∞–Ω–æ: {financials.get('total_donated', 0)}‚ÇΩ\n\n"
        ])

        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        first_seen = user_data.get('first_seen', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
        last_interaction = user_data.get('last_interaction', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')

        if isinstance(first_seen, datetime):
            first_seen = first_seen.strftime("%d.%m.%Y %H:%M")
        if isinstance(last_interaction, datetime):
            last_interaction = last_interaction.strftime("%d.%m.%Y %H:%M")

        text_lines.extend([
            f"<b>–ü–µ—Ä–≤–æ–µ –ø–æ—Å–µ—â–µ–Ω–∏–µ:</b> {first_seen}\n",
            f"<b>–ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:</b> {last_interaction}\n"
        ])

        current_model = user_data.get('current_model', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')
        current_chat_mode = user_data.get('current_chat_mode', '–Ω–µ —É–∫–∞–∑–∞–Ω')
        text_lines.extend([
            f"<b>–¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å:</b> {current_model}\n",
            f"<b>–†–µ–∂–∏–º —á–∞—Ç–∞:</b> {current_chat_mode}\n"
        ])

        return ''.join(text_lines)

============================================================

bot/base_handler.py:
========================================
import asyncio
import logging
from abc import ABC
from typing import Dict, Any

from telegram import (
    Update, User
)
from telegram.constants import ParseMode
from telegram.ext import (
    CallbackContext
)

import config
import database
from subscription import SubscriptionType
from subscription_config import SubscriptionConfig

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
db = database.Database()
bot_instance = None
user_semaphores: Dict[int, asyncio.Semaphore] = {}
user_tasks: Dict[int, asyncio.Task] = {}

class BaseHandler(ABC):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤."""

    def __init__(self, database: database.Database):
        self.db = database

    async def register_user_if_not_exists(self, update: Update, context: CallbackContext, user: User) -> bool:
        """–†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –æ–Ω –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."""
        user_registered_now = False

        if not self.db.check_if_user_exists(user.id):
            self.db.add_new_user(
                user.id,
                update.message.chat_id,
                username=user.username,
                first_name=user.first_name,
                last_name=user.last_name
            )
            self.db.add_subscription(user.id, SubscriptionType.FREE, 7)
            user_registered_now = True
            self.db.start_new_dialog(user.id)

        # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —Å–µ–º–∞—Ñ–æ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –î–û –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∞—Ç—Ä–∏–±—É—Ç–æ–≤
        if user.id not in user_semaphores:
            user_semaphores[user.id] = asyncio.Semaphore(1)
            logger.info(f"Initialized semaphore for new user {user.id}")

        await self._initialize_user_attributes(user.id)

        if user_registered_now:
            await self._send_registration_notification(context, user)

        return user_registered_now

    async def _initialize_user_attributes(self, user_id: int) -> None:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–º–∞—Ñ–æ—Ä–∞ –î–û –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        if user_id not in user_semaphores:
            user_semaphores[user_id] = asyncio.Semaphore(1)
            logger.info(f"Initialized semaphore for user {user_id}")

        if self.db.get_user_attribute(user_id, "current_dialog_id") is None:
            self.db.start_new_dialog(user_id)

        attributes_to_init = [
            ("current_model", config.models["available_text_models"][0]),
            ("n_used_tokens", {}),
            ("n_transcribed_seconds", 0.0),
            ("n_generated_images", 0)
        ]

        for attr, default_value in attributes_to_init:
            if self.db.get_user_attribute(user_id, attr) is None:
                self.db.set_user_attribute(user_id, attr, default_value)

    async def _send_registration_notification(self, context: CallbackContext, user: User) -> None:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º."""
        username = user.username or "No username"
        first_name = user.first_name or "No first name"
        last_name = user.last_name or "No last name"

        notification_text = (
            f"A new user has just registered!\n\n"
            f"Username: {username}\n"
            f"First Name: {first_name}\n"
            f"Last Name: {last_name}"
        )

        for admin_id in config.roles.get('admin', []):
            try:
                await context.bot.send_message(chat_id=admin_id, text=notification_text)
            except Exception as e:
                logger.warning(f"Failed to send registration to admin {admin_id}: {e}")

    async def is_previous_message_not_answered_yet(self, update: Update, context: CallbackContext) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –ª–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id

        if user_semaphores[user_id].locked():
            text = "‚è≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, <b>–ø–æ–¥–æ–∂–¥–∏—Ç–µ</b> –æ—Ç–≤–µ—Ç –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ\n–ò–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ –µ–≥–æ –∫–æ–º–∞–Ω–¥–æ–π /cancel"
            await update.message.reply_text(text, reply_to_message_id=update.message.id, parse_mode=ParseMode.HTML)
            return True
        return False

    async def subscription_preprocessor(self, update: Update, context: CallbackContext) -> bool:
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏."""
        try:
            user_id = update.effective_user.id

            # –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            if not self.db.check_if_user_exists(user_id):
                await self.register_user_if_not_exists(update, context, update.effective_user)

            subscription_info = self.db.get_user_subscription_info(user_id)

            if not subscription_info["is_active"]:
                await update.message.reply_text(
                    "‚ùå –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞. "
                    "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏–æ–±—Ä–µ—Ç–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É —á–µ—Ä–µ–∑ /subscription",
                    parse_mode=ParseMode.HTML
                )
                return False

            return await self._check_subscription_limits(subscription_info, update)
        except Exception as e:
            logger.error(f"Subscription preprocessor error: {e}")
            return False

    async def _check_subscription_limits(self, subscription_info: Dict[str, Any], update: Update) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ª–∏–º–∏—Ç—ã –ø–æ–¥–ø–∏—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é."""
        subscription_type = SubscriptionType(subscription_info["type"])

        if not SubscriptionConfig.can_make_request(subscription_type, subscription_info["requests_used"]):
            description = SubscriptionConfig.get_description(subscription_type)
            await update.message.reply_text(
                f"‚ùå –õ–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ–¥–ø–∏—Å–∫–∏ {description['name']} –∏—Å—á–µ—Ä–ø–∞–Ω. "
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É —á–µ—Ä–µ–∑ /subscription",
                parse_mode=ParseMode.HTML
            )
            return False

        return True

============================================================

bot/bot.py:
========================================
import asyncio
import html
import json
import logging
import traceback
from typing import Dict

from telegram import (
    Update, BotCommand, BotCommandScopeAllPrivateChats
)
from telegram.ext import (
    Application, ApplicationBuilder, CallbackContext, CommandHandler,
    MessageHandler, CallbackQueryHandler, AIORateLimiter, filters
)
from yookassa import Payment, Configuration

import config
import database
from admin_handlers import AdminHandlers
from chat_mode_handlers import ChatModeHandlers
from image_handlers import ImageHandlers
from message_handlers import MessageHandlers
from payment import process_successful_payment
from settings_handlers import SettingsHandlers
from subscription_handlers import SubscriptionHandlers
from utils import update_user_roles_from_config, configure_logging

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
db = database.Database()
bot_instance = None
user_semaphores: Dict[int, asyncio.Semaphore] = {}
user_tasks: Dict[int, asyncio.Task] = {}

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã —Å–æ–æ–±—â–µ–Ω–∏–π
HELP_MESSAGE = """<b>–ö–æ–º–∞–Ω–¥—ã:</b>
/new ‚Äì –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥ üÜï
/retry ‚Äì –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å üîÅ
/mode ‚Äì –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º
/subscription ‚Äì –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∞–º–∏ üîî
/my_payments ‚Äì –ú–æ–∏ –ø–ª–∞—Ç–µ–∂–∏ üìã
/help ‚Äì –ü–æ–º–æ—â—å ‚ùì

üé§ –í—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å <b>–≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b> –≤–º–µ—Å—Ç–æ —Ç–µ–∫—Å—Ç–∞

<blockquote>
1. –ß–∞—Ç –ø–æ–º–Ω–∏—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è 10 –º–∏–Ω—É—Ç. –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ ‚Äî /new
2. ¬´–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç¬ª ‚Äî —Ä–µ–∂–∏–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–∏–µ —Ä–µ–∂–∏–º—ã: /mode
</blockquote>
"""

HELP_GROUP_CHAT_MESSAGE = """–í—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –±–æ—Ç–∞ –≤ –ª—é–±–æ–π <b>–≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç</b> —á—Ç–æ–±—ã –ø–æ–º–æ–≥–∞—Ç—å –∏ —Ä–∞–∑–≤–ª–µ–∫–∞—Ç—å –µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤!

–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:
1. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç
2. –°–¥–µ–ª–∞–π—Ç–µ –µ–≥–æ <b>–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º</b>, —á—Ç–æ–±—ã –æ–Ω –º–æ–≥ –≤–∏–¥–µ—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è
3. –í—ã –≤–µ–ª–∏–∫–æ–ª–µ–ø–Ω—ã!

–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç –±–æ—Ç–∞ –≤ —á–∞—Ç–µ ‚Äì @ <b>—É–ø–æ–º—è–Ω–∏—Ç–µ</b> –µ–≥–æ –∏–ª–∏ <b>–æ—Ç–≤–µ—Ç—å—Ç–µ</b> –Ω–∞ –µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.
–ù–∞–ø—Ä–∏–º–µ—Ä: "{bot_username} –Ω–∞–ø–∏—à–∏ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏–µ –æ Telegram"
"""


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞
async def post_init(application: Application) -> None:
    """–§—É–Ω–∫—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞."""
    commands = [
        BotCommand("/new", "–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥ üÜï"),
        BotCommand("/retry", "–ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å üîÅ"),
        BotCommand("/mode", "–í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º"),
        BotCommand("/subscription", "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∞–º–∏ üîî"),
        BotCommand("/my_payments", "–ú–æ–∏ –ø–ª–∞—Ç–µ–∂–∏ üìã"),
        BotCommand("/help", "–ü–æ–º–æ—â—å ‚ùì"),
    ]

    await application.bot.set_my_commands(commands, scope=BotCommandScopeAllPrivateChats())

    if config.yookassa_shop_id and config.yookassa_secret_key:
        application.job_queue.run_repeating(
            check_pending_payments_wrapper,
            interval=30,
            first=10
        )


async def check_pending_payments_wrapper(context: CallbackContext) -> None:
    """–û–±–µ—Ä—Ç–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ pending –ø–ª–∞—Ç–µ–∂–µ–π."""
    try:
        await check_pending_payments()
    except Exception as e:
        logger.error(f"Error in payment checking job: {e}")


async def check_pending_payments() -> None:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç–∞—Ç—É—Å pending –ø–ª–∞—Ç–µ–∂–µ–π."""
    try:
        pending_payments = db.get_pending_payments()
        for payment in pending_payments:
            payment_id = payment["payment_id"]
            user_id = payment["user_id"]

            try:
                payment_info = Payment.find_one(payment_id)
                status = payment_info.status
                db.update_payment_status(payment_id, status)

                if status == 'succeeded':
                    await process_successful_payment(payment_info, user_id)
                elif status == 'canceled':
                    logger.info(f"Payment {payment_id} was canceled")

            except Exception as e:
                logger.error(f"Error checking payment {payment_id}: {e}")

    except Exception as e:
        logger.error(f"Error in payment checking: {e}")


def run_bot() -> None:
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞."""
    global bot_instance

    if config.yookassa_shop_id and config.yookassa_secret_key:
        Configuration.account_id = config.yookassa_shop_id
        Configuration.secret_key = config.yookassa_secret_key

    update_user_roles_from_config(db, config.roles)
    configure_logging()

    application = (
        ApplicationBuilder()
        .token(config.telegram_token)
        .concurrent_updates(True)
        .rate_limiter(AIORateLimiter(max_retries=5))
        .http_version("1.1")
        .get_updates_http_version("1.1")
        .post_init(post_init)
        .build()
    )

    bot_instance = application.bot

    subscription_handlers = SubscriptionHandlers(db)
    image_handlers = ImageHandlers(db)
    chat_mode_handlers = ChatModeHandlers(db)
    admin_handlers = AdminHandlers(db)
    message_handlers = MessageHandlers(db, subscription_handlers, chat_mode_handlers, admin_handlers, image_handlers)
    settings_handlers = SettingsHandlers(db)

    user_filter = filters.ALL
    if config.allowed_telegram_usernames:
        usernames = [x for x in config.allowed_telegram_usernames if isinstance(x, str)]
        any_ids = [x for x in config.allowed_telegram_usernames if isinstance(x, int)]
        user_ids = [x for x in any_ids if x > 0]
        group_ids = [x for x in any_ids if x < 0]
        user_filter = (filters.User(username=usernames) |
                       filters.User(user_id=user_ids) |
                       filters.Chat(chat_id=group_ids))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", message_handlers.start_handle, filters=user_filter))
    application.add_handler(CommandHandler("help", message_handlers.help_handle, filters=user_filter))
    application.add_handler(CommandHandler("settings", settings_handlers.settings_handle, filters=user_filter))
    application.add_handler(
        CommandHandler("help_group_chat", message_handlers.help_group_chat_handle, filters=user_filter))
    application.add_handler(CommandHandler("retry", message_handlers.retry_handle, filters=user_filter))
    application.add_handler(CommandHandler("new", message_handlers.new_dialog_handle, filters=user_filter))
    application.add_handler(CommandHandler("cancel", message_handlers.cancel_handle, filters=user_filter))
    application.add_handler(CommandHandler("mode", chat_mode_handlers.show_chat_modes_handle, filters=user_filter))
    application.add_handler(
        CommandHandler("my_payments", subscription_handlers.my_payments_handle, filters=user_filter))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏
    application.add_handler(CommandHandler("edit_user", admin_handlers.edit_user_command, filters=user_filter))
    application.add_handler(CommandHandler("broadcast", admin_handlers.broadcast_command, filters=user_filter))
    application.add_handler(CommandHandler("user_data", admin_handlers.get_user_data_command, filters=user_filter))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & user_filter,
                                           message_handlers.message_handle))
    application.add_handler(MessageHandler(filters.VOICE & user_filter,
                                           message_handlers.voice_message_handle))

    # –î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π —Å –ø–æ–¥–ø–∏—Å—è–º–∏
    application.add_handler(MessageHandler(
        filters.PHOTO & filters.ChatType.PRIVATE,
        image_handlers.process_image_message_handle
    ))

    # –î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –≤ –≥—Ä—É–ø–ø–∞—Ö (–µ—Å–ª–∏ –±–æ—Ç —É–ø–æ–º—è–Ω—É—Ç)
    application.add_handler(MessageHandler(
        filters.PHOTO & filters.ChatType.GROUPS & filters.Entity("mention"),
        image_handlers.process_image_message_handle
    ))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–æ–¥–ø–∏—Å–æ–∫
    application.add_handler(
        CommandHandler("subscription", subscription_handlers.subscription_handle, filters=user_filter))
    application.add_handler(CallbackQueryHandler(subscription_handlers.subscription_callback_handle,
                                                 pattern='^subscribe\\|'))
    application.add_handler(CallbackQueryHandler(subscription_handlers.subscription_handle,
                                                 pattern='^subscription_back$'))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Ä–µ–∂–∏–º–æ–≤ —á–∞—Ç–∞
    application.add_handler(CallbackQueryHandler(chat_mode_handlers.show_chat_modes_callback_handle,
                                                 pattern="^show_chat_modes"))
    application.add_handler(CallbackQueryHandler(chat_mode_handlers.set_chat_mode_handle,
                                                 pattern="^set_chat_mode"))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^model-"
    ))
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^model-set_settings\\|"
    ))
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^claude-model-set_settings\\|"
    ))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Ö—É–¥–æ–∂–Ω–∏–∫–∞
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^model-artist"
    ))
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^model-artist-set_model\\|"
    ))
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^model-artist-set_images\\|"
    ))
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^model-artist-set_resolution\\|"
    ))
    application.add_handler(CallbackQueryHandler(
        settings_handlers.model_settings_handler,
        pattern="^model-artist-set_quality\\|"
    ))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏ (callback)
    application.add_handler(CallbackQueryHandler(admin_handlers.broadcast_confirmation_handler,
                                                 pattern="^confirm_broadcast\\|"))
    application.add_handler(CallbackQueryHandler(admin_handlers.broadcast_confirmation_handler,
                                                 pattern="^cancel_broadcast"))

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
    application.add_error_handler(error_handle)

    application.run_polling()


async def error_handle(update: Update, context: CallbackContext) -> None:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—à–∏–±–∫–∏ –±–æ—Ç–∞."""
    logger.error("Exception while handling an update:", exc_info=context.error)

    try:
        tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
        tb_string = "".join(tb_list)
        update_str = update.to_dict() if isinstance(update, Update) else str(update)

        message = (
            f"An exception was raised while handling an update\n"
            f"<pre>update = {html.escape(json.dumps(update_str, indent=2, ensure_ascii=False))}</pre>\n\n"
            f"<pre>{html.escape(tb_string)}</pre>"
        )

        error_for_user = (
            f"An unexpected error occurred. "
            f"Please try again or contact support if the issue persists."
        )

        await context.bot.send_message(update.effective_chat.id, error_for_user)

    except Exception as handler_error:
        logger.error("Error in error handler: %s", handler_error)


if __name__ == "__main__":
    run_bot()


============================================================

bot/chat_mode_handlers.py:
========================================
import logging
from datetime import datetime

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import CallbackContext
import telegram

import config
from base_handler import BaseHandler

logger = logging.getLogger(__name__)


class ChatModeHandlers(BaseHandler):
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ–∂–∏–º–æ–≤ —á–∞—Ç–∞."""

    @staticmethod
    def get_chat_mode_menu(page_index: int):
        """–°–æ–∑–¥–∞–µ—Ç –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–∞ —á–∞—Ç–∞."""
        n_chat_modes_per_page = config.n_chat_modes_per_page
        chat_mode_keys = list(config.chat_modes.keys())
        total_modes = len(chat_mode_keys)

        text = f"–í—ã–±–µ—Ä–∏—Ç–µ <b>—Ä–µ–∂–∏–º —á–∞—Ç–∞</b> (–î–æ—Å—Ç—É–ø–Ω–æ {total_modes} —Ä–µ–∂–∏–º–æ–≤):"

        # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∂–∏–º—ã –¥–ª—è —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        start_idx = page_index * n_chat_modes_per_page
        end_idx = start_idx + n_chat_modes_per_page
        page_chat_mode_keys = chat_mode_keys[start_idx:end_idx]

        # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏ —Ä–µ–∂–∏–º–æ–≤ (–ø–æ 2 –≤ —Å—Ç—Ä–æ–∫–µ)
        keyboard = []
        for i in range(0, len(page_chat_mode_keys), 2):
            row = [
                InlineKeyboardButton(
                    config.chat_modes[key]["name"],
                    callback_data=f"set_chat_mode|{key}"
                ) for key in page_chat_mode_keys[i:i + 2]
            ]
            keyboard.append(row)

        # –î–æ–±–∞–≤–ª—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if total_modes > n_chat_modes_per_page:
            is_first_page = (page_index == 0)
            is_last_page = (end_idx >= total_modes)

            pagination_buttons = []
            if not is_first_page:
                pagination_buttons.append(
                    InlineKeyboardButton("¬´", callback_data=f"show_chat_modes|{page_index - 1}")
                )
            if not is_last_page:
                pagination_buttons.append(
                    InlineKeyboardButton("¬ª", callback_data=f"show_chat_modes|{page_index + 1}")
                )

            if pagination_buttons:
                keyboard.append(pagination_buttons)

        return text, InlineKeyboardMarkup(keyboard)

    async def _process_user_interaction(self, update: Update, context: CallbackContext, from_callback: bool = False):
        """–û–±—â–∞—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è."""
        user_data = update.callback_query.from_user if from_callback else update.message.from_user
        await self.register_user_if_not_exists(update, context, user_data)

        if not from_callback and await self.is_previous_message_not_answered_yet(update, context):
            return False

        user_id = user_data.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())
        return True

    async def show_chat_modes_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /mode."""
        if not await self._process_user_interaction(update, context, from_callback=False):
            return

        text, reply_markup = self.get_chat_mode_menu(0)
        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

    async def show_chat_modes_callback_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç callback –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ —Ä–µ–∂–∏–º–æ–≤ —á–∞—Ç–∞."""
        if not await self._process_user_interaction(update, context, from_callback=True):
            return

        query = update.callback_query
        await query.answer()

        page_index = int(query.data.split("|")[1])
        if page_index < 0:
            return

        text, reply_markup = self.get_chat_mode_menu(page_index)
        try:
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
        except telegram.error.BadRequest as e:
            if not str(e).startswith("Message is not modified"):
                raise e

    async def set_chat_mode_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ —á–∞—Ç–∞."""
        await self._process_user_interaction(update, context, from_callback=True)

        query = update.callback_query
        await query.answer()

        chat_mode = query.data.split("|")[1]
        user_id = query.from_user.id

        self.db.set_user_attribute(user_id, "current_chat_mode", chat_mode)
        self.db.start_new_dialog(user_id)

        welcome_message = config.chat_modes[chat_mode]["welcome_message"]
        await context.bot.send_message(
            query.message.chat.id,
            welcome_message,
            parse_mode=ParseMode.HTML
        )

============================================================

bot/code_collector.py:
========================================
import os
import glob


def simple_collect_code(output_file="project_code.txt"):
    """
    –ü—Ä–æ—Å—Ç–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Å–±–æ—Ä–∞ Python —Ñ–∞–π–ª–æ–≤
    """
    # –ò—â–µ–º –≤—Å–µ .py —Ñ–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö
    py_files = glob.glob('**/*.py', recursive=True)

    # –ò—Å–∫–ª—é—á–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    exclude_dirs = ['__pycache__', '.git', 'venv', 'env']
    filtered_files = [f for f in py_files if not any(exclude in f for exclude in exclude_dirs)]

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∏–º–µ–Ω–∏
    filtered_files.sort()

    with open(output_file, 'w', encoding='utf-8') as out_file:
        for file_path in filtered_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as in_file:
                    content = in_file.read()

                out_file.write(f"{file_path}:\n")
                out_file.write("=" * 40 + "\n")
                out_file.write(content)
                out_file.write("\n\n" + "=" * 60 + "\n\n")

                print(f"–î–æ–±–∞–≤–ª–µ–Ω: {file_path}")

            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ —Å —Ñ–∞–π–ª–æ–º {file_path}: {e}")

    print(f"\n–ì–æ—Ç–æ–≤–æ! –§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ {output_file}")


# –ó–∞–ø—É—Å–∫
if __name__ == "__main__":
    simple_collect_code()

============================================================

bot/config.py:
========================================
import yaml
import dotenv
from pathlib import Path

config_dir = Path(__file__).parent.parent.resolve() / "config"

# load yaml config
with open(config_dir / "config.yml", 'r') as f:
    config_yaml = yaml.safe_load(f)

# load .env config
config_env = dotenv.dotenv_values(config_dir / "config.env")

# config parameters
telegram_token = config_yaml["telegram_token"]
openai_api_key = config_yaml["openai_api_key"]
anthropic_api_key = config_yaml.get("anthropic_api_key", None)
yookassa_shop_id = config_yaml.get("yookassa_shop_id", None)
yookassa_secret_key = config_yaml.get("yookassa_secret_key", None)
developer_username = config_yaml.get("developer_username", "")
timezone = config_yaml.get("database_timezone", "UTC")
enable_detailed_logging = config_yaml.get("enable_detailed_logging", True)
openai_api_base = config_yaml.get("openai_api_base", None)
allowed_telegram_usernames = config_yaml["allowed_telegram_usernames"]
new_dialog_timeout = config_yaml["new_dialog_timeout"]
enable_message_streaming = config_yaml.get("enable_message_streaming", True)
return_n_generated_images = config_yaml.get("return_n_generated_images", 1)
image_size = config_yaml.get("image_size", "512x512")
n_chat_modes_per_page = config_yaml.get("n_chat_modes_per_page", 5)
mongodb_uri = f"mongodb://mongo:{config_env['MONGODB_PORT']}"
model_pricing = config_yaml.get('model_pricing', {})
role_deduction_rates = config_yaml.get('role_deduction_rates', {})
roles = config_yaml.get('roles', {})

# chat_modes
with open(config_dir / "chat_modes.yml", 'r') as f:
    chat_modes = yaml.safe_load(f)

# models
with open(config_dir / "models.yml", 'r') as f:
    models = yaml.safe_load(f)

# files
help_group_chat_video_path = Path(__file__).parent.parent.resolve() / "static" / "help_group_chat.mp4"
payment_banner_photo_path = Path(__file__).parent.parent.resolve() / "static" / "payment_banner.png"

============================================================

bot/database.py:
========================================
from typing import Optional, Any, List, Dict
import pymongo
import logging
from pymongo import UpdateOne
import uuid
from datetime import datetime, timedelta
import config
from subscription import SubscriptionType

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)


class Database:
    def __init__(self):
        self.client = pymongo.MongoClient(config.mongodb_uri)
        self.db = self.client["chatgpt_telegram_bot"]

        self.user_collection = self.db["user"]
        self.subscription_collection = self.db["subscriptions"]
        self.dialog_collection = self.db["dialog"]
        self.payment_collection = self.db["payments"]

        # –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        self._create_indexes()

    def _create_indexes(self):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–æ–≤ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—Ä–æ—Å–æ–≤"""
        self.user_collection.create_index("username")
        self.user_collection.create_index("role")
        self.user_collection.create_index("last_interaction")

        self.subscription_collection.create_index([
            ("user_id", pymongo.ASCENDING),
            ("expires_at", pymongo.ASCENDING)
        ])
        self.subscription_collection.create_index("expires_at")

        self.dialog_collection.create_index([
            ("user_id", pymongo.ASCENDING),
            ("_id", pymongo.ASCENDING)
        ])

        self.payment_collection.create_index("payment_id", unique=True)
        self.payment_collection.create_index([
            ("user_id", pymongo.ASCENDING),
            ("status", pymongo.ASCENDING)
        ])

    def check_if_user_exists(self, user_id: int, raise_exception: bool = False) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π —á–µ—Ä–µ–∑ find_one"""
        user = self.user_collection.find_one({"_id": user_id}, {"_id": 1})

        if user:
            return True
        else:
            if raise_exception:
                raise ValueError(f"User {user_id} does not exist")
            return False

    def add_new_user(
            self,
            user_id: int,
            chat_id: int,
            username: str = "",
            first_name: str = "",
            last_name: str = "",
    ) -> bool:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —á–µ—Ä–µ–∑ insert_one"""
        user_dict = {
            "_id": user_id,
            "chat_id": chat_id,

            "username": username,
            "first_name": first_name,
            "last_name": last_name,

            "last_interaction": datetime.now(),
            "first_seen": datetime.now(),

            "current_dialog_id": None,
            "current_chat_mode": "default",
            "current_model": config.models["available_text_models"][3],
            "image_preferences": {
                "model": config.models["available_image_models"][0],
                "quality": "standard",
                "resolution": "1024x1024",
                "n_images": 1
            },

            "n_used_tokens": {},
            "total_spent": 0,
            "dalle_2": {"images": 0, "cost": 0.0},
            "dalle_3": {"images": 0, "cost": 0.0},
            "n_generated_images": 0,
            "n_transcribed_seconds": 0.0,
            "token_balance": 100000,
            "role": "trial_user",
            "euro_balance": 1,
            "rub_balance": 100,
            "total_topup": 0,
            "total_donated": 0
        }

        try:
            self.user_collection.insert_one(user_dict)
            return True
        except pymongo.errors.DuplicateKeyError:
            return False

    def _get_user_document(self, user_id: int, projection: Optional[Dict] = None) -> Dict:
        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
        user = self.user_collection.find_one({"_id": user_id}, projection)
        if not user:
            raise ValueError(f"User {user_id} does not exist")
        return user

    def start_new_dialog(self, user_id: int) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞ —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏"""
        self.check_if_user_exists(user_id, raise_exception=True)

        subscription_info = self.get_user_subscription_info(user_id)
        if not subscription_info["is_active"]:
            raise PermissionError("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏")

        dialog_id = str(uuid.uuid4())
        current_time = datetime.now()

        dialog_dict = {
            "_id": dialog_id,
            "user_id": user_id,
            "chat_mode": self.get_user_attribute(user_id, "current_chat_mode"),
            "start_time": current_time,
            "model": self.get_user_attribute(user_id, "current_model"),
            "messages": []
        }

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º bulk operations –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏
        operations = [
            UpdateOne(
                {"_id": user_id},
                {"$set": {"current_dialog_id": dialog_id, "last_interaction": current_time}}
            )
        ]

        self.dialog_collection.insert_one(dialog_dict)
        self.user_collection.bulk_write(operations)

        return dialog_id

    def get_user_attribute(self, user_id: int, key: str) -> Any:
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∞—Ç—Ä–∏–±—É—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        try:
            result = self.user_collection.find_one(
                {"_id": user_id},
                {key: 1}
            )
            return result.get(key) if result else None
        except Exception as e:
            logger.error(f"Error getting attribute {key} for user {user_id}: {e}")
            return None

    def set_user_attribute(self, user_id: int, key: str, value: Any) -> None:
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞—Ç—Ä–∏–±—É—Ç–∞ —Å bulk operations."""
        try:
            self.user_collection.update_one(
                {"_id": user_id},
                {
                    "$set": {
                        key: value,
                        "last_interaction": datetime.now()
                    }
                },
                upsert=False
            )
        except Exception as e:
            logger.error(f"Error setting attribute {key} for user {user_id}: {e}")

    def update_n_used_tokens(self, user_id: int, model: str, n_input_tokens: int, n_output_tokens: int) -> None:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–æ–≤ —Ç–æ–∫–µ–Ω–æ–≤ —Å –∞—Ç–æ–º–∞—Ä–Ω—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏"""
        update_query = {
            "$inc": {
                f"n_used_tokens.{model}.n_input_tokens": n_input_tokens,
                f"n_used_tokens.{model}.n_output_tokens": n_output_tokens
            },
            "$set": {"last_interaction": datetime.now()}
        }

        self.user_collection.update_one({"_id": user_id}, update_query, upsert=True)

    def get_dialog_messages(self, user_id: int, dialog_id: Optional[str] = None) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–∏–∞–ª–æ–≥–∞ —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∑–∞–ø—Ä–æ—Å–æ–º"""
        self.check_if_user_exists(user_id, raise_exception=True)

        if dialog_id is None:
            dialog_id = self.get_user_attribute(user_id, "current_dialog_id")

        dialog = self.dialog_collection.find_one(
            {"_id": dialog_id, "user_id": user_id},
            {"messages": 1}
        )
        return dialog["messages"] if dialog else []

    def set_dialog_messages(self, user_id: int, dialog_messages: List[Dict], dialog_id: Optional[str] = None) -> None:
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–∏–∞–ª–æ–≥–∞"""
        self.check_if_user_exists(user_id, raise_exception=True)

        if dialog_id is None:
            dialog_id = self.get_user_attribute(user_id, "current_dialog_id")

        self.dialog_collection.update_one(
            {"_id": dialog_id, "user_id": user_id},
            {"$set": {"messages": dialog_messages}}
        )

    # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–ª–∞–Ω—Å–∞–º–∏
    def get_user_role(self, user_id: int) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≤ –±—É–¥—É—â–µ–º"""
        user = self.user_collection.find_one(
            {"_id": user_id},
            {"role": 1}
        )
        return user.get("role", "trial_user") if user else "trial_user"

    def get_user_model(self, user_id: int) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        user = self.user_collection.find_one(
            {"_id": user_id},
            {"current_model": 1}
        )
        return user.get("current_model", "gpt-3.5-turbo") if user else "gpt-3.5-turbo"

    def get_user_last_interaction(self, user_id: int) -> datetime:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è"""
        user = self.user_collection.find_one(
            {"_id": user_id},
            {"last_interaction": 1}
        )
        return user.get("last_interaction") if user else datetime.min

    def get_user_count(self) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        return self.user_collection.count_documents({})

    def get_all_user_ids(self) -> List[int]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø—Ä–æ–µ–∫—Ü–∏–µ–π"""
        return [user["_id"] for user in self.user_collection.find({}, {"_id": 1})]

    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID"""
        return self.user_collection.find_one({"_id": user_id})

    def get_users_and_roles(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∏—Ö —Ä–æ–ª–µ–π —Å –ø—Ä–æ–µ–∫—Ü–∏–µ–π"""
        return list(self.user_collection.find(
            {},
            {"username": 1, "first_name": 1, "role": 1, "last_interaction": 1}
        ))

    def find_users_by_role(self, role: str) -> List[Dict]:
        """–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ —Ä–æ–ª–∏"""
        return list(self.user_collection.find({"role": role}))

    def find_user_by_username(self, username: str) -> Optional[Dict]:
        """–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username"""
        return self.user_collection.find_one({"username": username})

    def find_users_by_first_name(self, first_name: str) -> List[Dict]:
        """–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –∏–º–µ–Ω–∏"""
        return list(self.user_collection.find({"first_name": first_name}))

    # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–µ—Ç–æ–¥—ã —Ä–∞–±–æ—Ç—ã —Å —Ñ–∏–Ω–∞–Ω—Å–∞–º–∏
    def get_user_financials(self, user_id: int) -> Dict[str, float]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        user_data = self.user_collection.find_one(
            {"_id": user_id},
            {"total_topup": 1, "total_donated": 1}
        )
        return {
            "total_topup": user_data.get("total_topup", 0) if user_data else 0,
            "total_donated": user_data.get("total_donated", 0) if user_data else 0
        }

    def add_subscription(self, user_id: int, subscription_type: SubscriptionType,
                         duration_days: int) -> None:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
        purchased_at = datetime.now()
        expires_at = purchased_at + timedelta(days=duration_days)

        subscription_data = {
            "user_id": user_id,
            "type": subscription_type.value,
            "purchased_at": purchased_at,
            "expires_at": expires_at,
            "requests_used": 0,
            "images_used": 0
        }

        self.subscription_collection.insert_one(subscription_data)

    def get_active_subscription(self, user_id: int) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return self.subscription_collection.find_one({
            "user_id": user_id,
            "expires_at": {"$gt": datetime.now()}
        }, sort=[("purchased_at", pymongo.DESCENDING)])

    def update_subscription_usage(self, user_id: int, request_used: bool = False,
                                  image_used: bool = False) -> None:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏"""
        update_data = {}
        if request_used:
            update_data["$inc"] = {"requests_used": 1}
        if image_used:
            update_data["$inc"] = update_data.get("$inc", {})
            update_data["$inc"]["images_used"] = 1

        if update_data:
            self.subscription_collection.update_one(
                {"user_id": user_id, "expires_at": {"$gt": datetime.now()}},
                update_data
            )

    def get_user_subscription_info(self, user_id: int) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–¥–ø–∏—Å–∫–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        subscription = self.get_active_subscription(user_id)
        if subscription:
            return {
                "type": subscription["type"],
                "expires_at": subscription["expires_at"],
                "requests_used": subscription.get("requests_used", 0),
                "images_used": subscription.get("images_used", 0),
                "is_active": True
            }
        else:
            return {
                "type": "free",
                "is_active": False,
                "requests_used": 0,
                "images_used": 0
            }

    # –ú–µ—Ç–æ–¥—ã –ø–ª–∞—Ç–µ–∂–µ–π —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
    def create_payment(self, user_id: int, payment_id: str, amount: float,
                       payment_type: str, description: str = "") -> None:
        """–°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –æ –ø–ª–∞—Ç–µ–∂–µ"""
        current_time = datetime.now()
        payment_data = {
            "user_id": user_id,
            "payment_id": payment_id,
            "amount": amount,
            "currency": "RUB",
            "type": payment_type,
            "description": description,
            "status": "pending",
            "created_at": current_time,
            "updated_at": current_time
        }

        try:
            self.payment_collection.insert_one(payment_data)
        except pymongo.errors.DuplicateKeyError:
            raise ValueError(f"Payment with ID {payment_id} already exists")

    def update_payment_status(self, payment_id: str, status: str) -> None:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–∞—Ç–µ–∂–∞"""
        self.payment_collection.update_one(
            {"payment_id": payment_id},
            {
                "$set": {
                    "status": status,
                    "updated_at": datetime.now()
                }
            }
        )

    def get_pending_payments(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ pending –ø–ª–∞—Ç–µ–∂–µ–π"""
        return list(self.payment_collection.find({
            "status": {"$in": ["pending", "waiting_for_capture"]}
        }))

    def get_payment_by_id(self, payment_id: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ –ø–æ ID"""
        return self.payment_collection.find_one({"payment_id": payment_id})

    def get_user_pending_payments(self, user_id: int) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ pending –ø–ª–∞—Ç–µ–∂–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return list(self.payment_collection.find({
            "user_id": user_id,
            "status": {"$in": ["pending", "waiting_for_capture"]}
        }))


============================================================

bot/image_handlers.py:
========================================
import io
import logging
from datetime import datetime
from typing import Optional, List

import asyncio
import aiohttp
import telegram
from telegram import Update, InputFile
from telegram.constants import ParseMode
from telegram.ext import CallbackContext

import openai_utils
from base_handler import BaseHandler

logger = logging.getLogger(__name__)


class ImageHandlers(BaseHandler):
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π."""

    async def generate_image_handle(self, update: Update, context: CallbackContext,
                                    message: Optional[str] = None) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π."""
        user = update.message.from_user

        await self.register_user_if_not_exists(update, context, user)
        if await self.is_previous_message_not_answered_yet(update, context):
            return

        user_id = user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        if not await self.subscription_preprocessor(update, context):
            return

        await update.message.chat.send_action(action="upload_photo")

        prompt = message or update.message.text

        placeholder_message = await update.message.reply_text(
            "<i>–†–∏—Å—É–µ–º...</i>",
            parse_mode=ParseMode.HTML
        )

        try:
            image_urls = await self._generate_images(user_id, prompt)

            await self._send_generated_images(
                update,
                context,
                prompt,
                image_urls,
                placeholder_message
            )

        except Exception as e:
            await self._handle_image_generation_error(update, e)

    async def _generate_images(self, user_id: int, prompt: str) -> List[str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ OpenAI API."""
        prefs = self.db.get_user_attribute(user_id, "image_preferences") or {}

        model = prefs.get("model", "dall-e-3")
        resolution = prefs.get("resolution", "1024x1024")

        try:
            # –û–±–µ—Ä—Ç—ã–≤–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –≤—ã–∑–æ–≤ –≤ asyncio.to_thread
            image_urls = await asyncio.to_thread(
                openai_utils.generate_images,
                prompt=prompt,
                model=model,
                size=resolution
            )
            return image_urls

        except Exception as e:
            # Fallback –¥–ª—è DALL-E 3 ‚Üí DALL-E 2
            if any(keyword in str(e).lower() for keyword in ["rejected", "safety", "billing", "quota"]):
                logger.warning("FALLBACK dalle-3 ‚Üí dalle-2")
                try:
                    image_urls = await asyncio.to_thread(
                        openai_utils.generate_images,
                        prompt=prompt,
                        model="dall-e-2",
                        size="1024x1024"
                    )
                    return image_urls
                except Exception:
                    raise e
            else:
                raise

    def _update_image_usage_stats(self, user_id: int, n_images: int) -> None:
        count = self.db.get_user_attribute(user_id, "n_generated_images") or 0
        self.db.set_user_attribute(user_id, "n_generated_images", count + n_images)

    async def _send_generated_images(self, update: Update, context: CallbackContext,
                                     prompt: str, image_urls: List[str],
                                     placeholder_message: telegram.Message) -> None:
        chat_id = placeholder_message.chat_id
        m_id = placeholder_message.message_id

        try:
            await context.bot.edit_message_text(
                f"üñº –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º...\n\n<i>{prompt}</i>",
                chat_id=chat_id,
                message_id=m_id,
                parse_mode=ParseMode.HTML
            )
        except telegram.error.BadRequest:
            pass

        async with aiohttp.ClientSession() as session:
            for url in image_urls:
                await update.message.chat.send_action(action="upload_photo")
                await self._send_one_image(session, context.bot, chat_id, url)

        await context.bot.edit_message_text(
            f"–ì–æ—Ç–æ–≤–æ üé®\n\n<i>{prompt}</i>",
            chat_id=chat_id,
            message_id=m_id,
            parse_mode=ParseMode.HTML
        )

    async def _send_one_image(self, session: aiohttp.ClientSession, bot: telegram.Bot, chat_id: int, url: str):
        """–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."""
        async with session.get(url) as resp:
            if resp.status != 200:
                logger.error(f"Failed download {url} ‚Äî {resp.status}")
                return

            img = io.BytesIO(await resp.read())
            img.name = "image.jpg"

            await bot.send_photo(chat_id=chat_id, photo=InputFile(img))

    async def _handle_image_generation_error(self, update: Update, error: Exception) -> None:
        msg = str(error)

        if msg.startswith("Your request was rejected"):
            text = (
                "üö´ <b>–ó–∞–ø—Ä–æ—Å –æ—Ç–∫–ª–æ–Ω—ë–Ω –ø–æ–ª–∏—Ç–∏–∫–∞–º–∏ OpenAI.</b>\n"
                "–ü–æ–ø—Ä–æ–±—É–π —Å—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –º—è–≥—á–µ ü´£"
            )
        else:
            text = (
                "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.\n"
                f"<b>–ü—Ä–∏—á–∏–Ω–∞:</b> {msg}"
            )

        await update.message.reply_text(text, parse_mode=ParseMode.HTML)

    async def process_image_message_handle(self, update: Update, context: CallbackContext,
                                           message: Optional[str] = None) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è/—É–ª—É—á—à–µ–Ω–∏—è."""
        user = update.message.from_user

        await self.register_user_if_not_exists(update, context, user)
        if await self.is_previous_message_not_answered_yet(update, context):
            return

        user_id = user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        if not await self.subscription_preprocessor(update, context):
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ñ–æ—Ç–æ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏
        if not update.message.photo:
            await update.message.reply_text(
                "‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.",
                parse_mode=ParseMode.HTML
            )
            return

        await update.message.chat.send_action(action="upload_photo")

        placeholder_message = await update.message.reply_text(
            "<i>–û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...</i>",
            parse_mode=ParseMode.HTML
        )

        try:
            # –ü–æ–ª—É—á–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            photo = update.message.photo[-1]
            file = await context.bot.get_file(photo.file_id)
            img_bytes = await file.download_as_bytearray()

            # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ–º–ø—Ç (—Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä)
            prompt = message or update.message.caption or "–£–ª—É—á—à–∏ —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ
            result_url = await asyncio.to_thread(
                openai_utils.generate_image_with_input,
                prompt,
                img_bytes
            )

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            await self._send_edited_image(context, placeholder_message, result_url, prompt)

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            self._update_image_usage_stats(user_id, 1)

        except Exception as e:
            await self._handle_image_generation_error(update, e)

    async def _send_edited_image(self, context: CallbackContext, placeholder_message: telegram.Message,
                                 image_url: str, prompt: str) -> None:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."""
        chat_id = placeholder_message.chat_id
        message_id = placeholder_message.message_id

        try:
            await context.bot.edit_message_text(
                f"üé® –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...\n\n<i>{prompt}</i>",
                chat_id=chat_id,
                message_id=message_id,
                parse_mode=ParseMode.HTML
            )
        except telegram.error.BadRequest:
            pass

        # –°–∫–∞—á–∏–≤–∞–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        async with aiohttp.ClientSession() as session:
            async with session.get(image_url) as resp:
                if resp.status == 200:
                    img = io.BytesIO(await resp.read())
                    img.name = "edited_image.jpg"

                    await context.bot.send_photo(
                        chat_id=chat_id,
                        photo=InputFile(img),
                        caption=f"–ì–æ—Ç–æ–≤–æ üé®\n\n<i>{prompt}</i>",
                        parse_mode=ParseMode.HTML
                    )

        # –£–¥–∞–ª—è–µ–º placeholder —Å–æ–æ–±—â–µ–Ω–∏–µ
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)

============================================================

bot/keyboards.py:
========================================
"""
–ú–æ–¥—É–ª—å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä –±–æ—Ç–∞
"""

import emoji
from datetime import datetime
from telegram import ReplyKeyboardMarkup, KeyboardButton
import database
import config
from subscription import SubscriptionType
import logging

logger = logging.getLogger(__name__)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —ç–º–æ–¥–∑–∏ –∏ —Ç–µ–∫—Å—Ç–æ–≤
_EMOJI = {
    "green_circle": ":green_circle:",
    "red_circle": ":red_circle:",
    "money_bag": ":money_bag:",
    "red_heart": ":red_heart:",
    "woman_and_man_holding_hands": ":woman_and_man_holding_hands:",
    "heart_hands": ":heart_hands:",
    "smiling_face_with_sunglasses": ":smiling_face_with_sunglasses:",
    "back_arrow": ":right_arrow_curving_left:"
}

_SUBSCRIPTION_NAMES = {
    SubscriptionType.PRO_LITE: "–ü–æ–¥–ø–∏—Å–∫–∞ Pro Lite",
    SubscriptionType.PRO_PLUS: "–ü–æ–¥–ø–∏—Å–∫–∞ Pro Plus",
    SubscriptionType.PRO_PREMIUM: "–ü–æ–¥–ø–∏—Å–∫–∞ Pro Premium"
}

class BotKeyboards:
    """–ö–ª–∞—Å—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä –±–æ—Ç–∞"""

    @staticmethod
    async def get_main_keyboard(user_id: int) -> ReplyKeyboardMarkup:
        """
        –°–æ–∑–¥–∞–µ—Ç –≥–ª–∞–≤–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø–æ–¥–ø–∏—Å–∫–µ –∏ –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏

        Args:
            user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

        Returns:
            ReplyKeyboardMarkup: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
        """
        db_instance = database.Database()
        subscription_info = db_instance.get_user_subscription_info(user_id)

        keyboard = [[KeyboardButton(BotKeyboards._get_subscription_status_text(subscription_info))]]

        # –û—Å–Ω–æ–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
        keyboard.extend([
            [
                KeyboardButton(emoji.emojize(f"–ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É {_EMOJI['money_bag']}")),
                KeyboardButton(emoji.emojize(f"–í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º {_EMOJI['red_heart']}"))
            ],
            [
                KeyboardButton(emoji.emojize(f"–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å {_EMOJI['woman_and_man_holding_hands']}")),
                KeyboardButton(emoji.emojize(f"–ü–æ–º–æ—â—å {_EMOJI['heart_hands']}"))
            ]
        ])

        # –ö–Ω–æ–ø–∫–∞ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
        if str(user_id) in config.roles.get('admin', []):
            keyboard.append([KeyboardButton(emoji.emojize(f"–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å {_EMOJI['smiling_face_with_sunglasses']}"))])

        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    @staticmethod
    def _get_subscription_status_text(subscription_info: dict) -> str:
        """–§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–¥–ø–∏—Å–∫–∏"""
        if not subscription_info["is_active"]:
            return BotKeyboards._get_inactive_subscription_text(subscription_info)
        return BotKeyboards._get_active_subscription_text(subscription_info)

    @staticmethod
    def _get_active_subscription_text(subscription_info: dict) -> str:
        """–§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏"""
        expires_at = subscription_info["expires_at"]
        dateto = expires_at.strftime('%d.%m.%Y %H:%M')

        if expires_at > datetime(2100, 1, 1):
            return emoji.emojize(f"{_EMOJI['green_circle']} –ü–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ –Ω–∞–≤—Å–µ–≥–¥–∞")

        sub_name = _SUBSCRIPTION_NAMES.get(
            subscription_info["type"],
            "–¢–µ—Å—Ç–æ–≤–∞—è –ø–æ–¥–ø–∏—Å–∫–∞"
        )
        return emoji.emojize(f"{_EMOJI['green_circle']} {sub_name} –∞–∫—Ç–∏–≤–Ω–∞ –¥–æ: {dateto} –ú–°–ö")

    @staticmethod
    def _get_inactive_subscription_text(subscription_info: dict) -> str:
        """–§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç –¥–ª—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏"""
        expires_at = subscription_info.get("expires_at")
        if expires_at:
            dateto = expires_at.strftime('%d.%m.%Y %H:%M')
            return emoji.emojize(f"{_EMOJI['red_circle']} –ü–æ–¥–ø–∏—Å–∫–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å: {dateto} –ú–°–ö")
        return emoji.emojize(f"{_EMOJI['red_circle']} –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞")

    @staticmethod
    def get_back_keyboard() -> ReplyKeyboardMarkup:
        """
        –°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π "–ù–∞–∑–∞–¥"

        Returns:
            ReplyKeyboardMarkup: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–æ–π –Ω–∞–∑–∞–¥
        """
        keyboard = [
            [KeyboardButton(emoji.emojize(f"–ù–∞–∑–∞–¥ {_EMOJI['back_arrow']}"))]
        ]
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    @staticmethod
    def get_back_to_admin_keyboard() -> ReplyKeyboardMarkup:
        """
        –°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å.

        Returns:
            ReplyKeyboardMarkup: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ —Å –∫–Ω–æ–ø–∫–æ–π –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
        """
        keyboard = [
            [KeyboardButton(emoji.emojize("–ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"))],
            [KeyboardButton(emoji.emojize("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"))]
        ]
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

    @staticmethod
    def get_admin_keyboard() -> ReplyKeyboardMarkup:
        """
        –°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏

        Returns:
            ReplyKeyboardMarkup: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏
        """
        keyboard = [
            [KeyboardButton(emoji.emojize("–í—ã–≤–µ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"))],
            [KeyboardButton(emoji.emojize("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"))],
            [KeyboardButton(emoji.emojize("–î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"))],
            [KeyboardButton(emoji.emojize("–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É"))],
            [KeyboardButton(emoji.emojize("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"))]
        ]
        return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

============================================================

bot/message_handlers.py:
========================================
import asyncio
import base64
import io
import logging
from datetime import datetime
from typing import Optional, Dict, Any, List, Tuple

import emoji
import telegram
from telegram import (
    Update
)
from telegram.constants import ParseMode
from telegram.ext import (
    CallbackContext
)

import config
import database
import openai_utils
from base_handler import BaseHandler
from keyboards import BotKeyboards
from message_processor import MessageProcessor
from utils import get_user_semaphore, HELP_MESSAGE, HELP_GROUP_CHAT_MESSAGE

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
db = database.Database()
bot_instance = None
user_semaphores: Dict[int, asyncio.Semaphore] = {}
user_tasks: Dict[int, asyncio.Task] = {}

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã —Å–æ–æ–±—â–µ–Ω–∏–π
class MessageHandlers(MessageProcessor):
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π."""

    def __init__(self, database: database.Database, subscription_handlers: Any,
                 chat_mode_handlers: Any, admin_handlers: Any, image_handlers: Any):
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º BaseHandler
        BaseHandler.__init__(self, database)
        self.subscription_handlers = subscription_handlers
        self.chat_mode_handlers = chat_mode_handlers
        self.admin_handlers = admin_handlers
        self.image_handlers = image_handlers

    async def start_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /start."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        try:
            self.db.start_new_dialog(user_id)
            reply_text = self._get_welcome_message()
        except PermissionError:
            reply_text = self._get_no_subscription_message()

        reply_markup = await BotKeyboards.get_main_keyboard(user_id)
        await update.message.reply_text(reply_text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)

    @staticmethod
    def _get_welcome_message() -> str:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."""
        return (
                "üëã –ü—Ä–∏–≤–µ—Ç! –ú—ã <b>Ducks GPT</b>\n"
                "–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π —á–∞—Ç-–±–æ—Ç –Ω–∞ –±–∞–∑–µ <b>ChatGPT</b>\n"
                "–†–∞–¥—ã –∑–Ω–∞–∫–æ–º—Å—Ç–≤—É!\n\n"
                "–î–æ—Å—Ç—É–ø–Ω—ã –≤ <b>–†–§</b>üá∑üá∫\n"
                "<b>–î–∞—Ä–∏–º –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ 7 –¥–Ω–µ–π:</b>\n"
                "- 15 –∑–∞–ø—Ä–æ—Å–æ–≤\n"
                "- 3 –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\n\n"
                + HELP_MESSAGE
        )

    @staticmethod
    def _get_no_subscription_message() -> str:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏."""
        return (
                "üëã –ü—Ä–∏–≤–µ—Ç! –ú—ã <b>Ducks GPT</b>\n"
                "–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π —á–∞—Ç-–±–æ—Ç –Ω–∞ –±–∞–∑–µ <b>ChatGPT</b>\n"
                "–†–∞–¥—ã –∑–Ω–∞–∫–æ–º—Å—Ç–≤—É!\n\n"
                "‚ùå <b>–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞</b>\n\n"
                "üéÅ <b>100 ‚ÇΩ –∑–∞ –Ω–∞—à —Å—á—ë—Ç –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏!</b>\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /subscription —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏\n\n"
                + HELP_MESSAGE
        )

    async def help_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /help."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())
        await update.message.reply_text(HELP_MESSAGE, parse_mode=ParseMode.HTML)

    async def help_group_chat_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /help_group_chat."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        text = HELP_GROUP_CHAT_MESSAGE.format(bot_username="@" + context.bot.username)
        await update.message.reply_text(text, parse_mode=ParseMode.HTML)

    async def retry_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /retry."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        if await self.is_previous_message_not_answered_yet(update, context):
            return

        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        if not await self.subscription_preprocessor(update, context):
            return

        dialog_messages = self.db.get_dialog_messages(user_id, dialog_id=None)
        if not dialog_messages:
            await update.message.reply_text("–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ü§∑‚Äç‚ôÇÔ∏è")
            return

        last_dialog_message = dialog_messages.pop()
        self.db.set_dialog_messages(user_id, dialog_messages, dialog_id=None)

        await self.message_handle(update, context, message=last_dialog_message["user"], use_new_dialog_timeout=False)

    async def new_dialog_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /new –¥–ª—è –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –º–æ–¥–µ–ª—å —Å vision –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤—É—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        current_model = self.db.get_user_attribute(user_id, "current_model")
        if current_model == "gpt-4-vision-preview":
            self.db.set_user_attribute(user_id, "current_model", "gpt-4o")

        try:
            self.db.start_new_dialog(user_id)
            await update.message.reply_text("–ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥ ‚úÖ")

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ä–µ–∂–∏–º–∞ —á–∞—Ç–∞
            chat_mode = self.db.get_user_attribute(user_id, "current_chat_mode")
            await update.message.reply_text(
                f"{config.chat_modes[chat_mode]['welcome_message']}",
                parse_mode=ParseMode.HTML
            )
        except PermissionError:
            await update.message.reply_text(
                "‚ùå <b>–î–ª—è –Ω–∞—á–∞–ª–∞ –Ω–æ–≤–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞</b>\n\n"
                "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /subscription –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∞–º–∏",
                parse_mode=ParseMode.HTML
            )

    async def message_handle(self, update: Update, context: CallbackContext,
                             message: Optional[str] = None, use_new_dialog_timeout: bool = True) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è."""

        # –î–æ–±–∞–≤—å—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É API –∫–ª—é—á–µ–π
        if not config.openai_api_key:
            logger.error("OpenAI API key is not configured!")
            await update.message.reply_text(
                "‚ùå –ë–æ—Ç –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç API –∫–ª—é—á OpenAI.",
                parse_mode=ParseMode.HTML
            )
            return

        if not await self.is_bot_mentioned(update, context):
            return

        if update.edited_message is not None:
            await self.edited_message_handle(update, context)
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–æ–π –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
        if await self._is_main_menu_button(update.message.text):
            await self.handle_main_menu_buttons(update, context)
            return

        processed_message = self._process_message_text(update, context, message)
        await self.register_user_if_not_exists(update, context, update.message.from_user)

        if await self.is_previous_message_not_answered_yet(update, context):
            return

        user_id = update.message.from_user.id

        if not await self.subscription_preprocessor(update, context):
            return

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
        chat_mode = self.db.get_user_attribute(user_id, "current_chat_mode")

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤
        if chat_mode == "artist":
            await self.image_handlers.generate_image_handle(update, context, message=processed_message)
            return
        elif chat_mode == "stenographer":
            await self.voice_message_handle(update, context, message=processed_message)
            return

        await self._handle_text_message(update, context, processed_message, use_new_dialog_timeout)

    async def _handle_text_message(self, update: Update, context: CallbackContext,
                                   message: str, use_new_dialog_timeout: bool) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."""
        user_id = update.message.from_user.id

        task = asyncio.create_task(
            self._text_message_handle_fn(update, context, message, use_new_dialog_timeout)
        )

        await self.execute_user_task(user_id, task, update)

    async def _text_message_handle_fn(self, update: Update, context: CallbackContext,
                                      message: str, use_new_dialog_timeout: bool) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è)."""
        user_id = update.message.from_user.id

        try:
            logger.info(f"=== START TEXT MESSAGE PROCESSING ===")
            logger.info(f"User: {user_id}, Message: '{message}'")

            # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ —Å–µ–º–∞—Ñ–æ—Ä—É
            if user_id not in user_semaphores:
                logger.warning(f"Semaphore not found for user {user_id}, initializing...")
                user_semaphores[user_id] = asyncio.Semaphore(1)

            chat_mode = self.db.get_user_attribute(user_id, "current_chat_mode")
            logger.info(f"Chat mode: {chat_mode}")

            current_model = self.db.get_user_attribute(user_id, "current_model")
            logger.info(f"Current model: {current_model}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏
            logger.info("Checking subscription...")
            subscription_info = self.db.get_user_subscription_info(user_id)
            logger.info(f"Subscription info: {subscription_info}")

            await self.prepare_dialog(user_id, use_new_dialog_timeout, chat_mode, update)
            logger.info("Dialog prepared")

            if not message or len(message) == 0:
                await update.message.reply_text("ü•≤ You sent <b>empty message</b>. Please, try again!",
                                                parse_mode=ParseMode.HTML)
                return

            async with get_user_semaphore(user_id):
                logger.info("Acquired user semaphore")
                placeholder_message = await update.message.reply_text("<i>–î—É–º–∞—é...</i>", parse_mode=ParseMode.HTML)
                await update.message.chat.send_action(action="typing")
                logger.info("Sent typing action")

                dialog_messages = self.db.get_dialog_messages(user_id, dialog_id=None)
                logger.info(f"Retrieved {len(dialog_messages)} dialog messages")

                parse_mode = {
                    "html": ParseMode.HTML,
                    "markdown": ParseMode.MARKDOWN
                }[config.chat_modes[chat_mode]["parse_mode"]]

                logger.info(f"Using parse mode: {parse_mode}")

                chatgpt_instance = openai_utils.ChatGPT(model=current_model)
                logger.info("Created ChatGPT instance")

                if config.enable_message_streaming:
                    logger.info("Using streaming response")
                    await self._handle_streaming_response(
                        update, context, message, dialog_messages, chat_mode,
                        chatgpt_instance, placeholder_message, parse_mode, user_id
                    )
                else:
                    logger.info("Using non-streaming response")
                    answer, n_input_tokens, n_output_tokens = await self._get_non_streaming_response(
                        chatgpt_instance, message, dialog_messages, chat_mode
                    )
                    logger.info(f"Got response: {answer[:100]}...")

                    await self.edit_message_with_retry(context, placeholder_message, answer, chat_mode)
                    logger.info("Message edited")

                    new_dialog_message = {"user": [{"type": "text", "text": message}], "bot": answer,
                                          "date": datetime.now()}
                    self.update_dialog_and_tokens(user_id, new_dialog_message, n_input_tokens, n_output_tokens)
                    logger.info("Dialog updated")

            logger.info("=== TEXT MESSAGE PROCESSING COMPLETED ===")

        except Exception as e:
            logger.error(f"=== ERROR IN TEXT MESSAGE HANDLING ===", exc_info=True)
            logger.error(f"Error type: {type(e)}")
            logger.error(f"Error message: {str(e)}")
            logger.error(f"=== END ERROR ===")
            await self.handle_message_error(update, e)

    async def _handle_streaming_response(self, update: Update, context: CallbackContext, message: str,
                                         dialog_messages: List[Dict], chat_mode: str,
                                         chatgpt_instance: openai_utils.ChatGPT,
                                         placeholder_message: telegram.Message,
                                         parse_mode: str, user_id: int) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ—Ç–æ–∫–æ–≤—ã–π –æ—Ç–≤–µ—Ç –æ—Ç ChatGPT."""
        gen = chatgpt_instance.send_message_stream(message, dialog_messages=dialog_messages, chat_mode=chat_mode)

        full_answer = ""
        n_input_tokens, n_output_tokens = 0, 0
        prev_answer = ""
        last_update_time = datetime.now()

        async for gen_item in gen:
            status, answer, (chunk_n_input_tokens, chunk_n_output_tokens), n_first_dialog_messages_removed = gen_item

            full_answer = answer
            n_input_tokens, n_output_tokens = chunk_n_input_tokens, chunk_n_output_tokens

            current_time = datetime.now()
            time_diff = (current_time - last_update_time).total_seconds()

            should_update = (
                    time_diff > 0.5 or
                    abs(len(answer) - len(prev_answer)) > 50 or
                    status == "finished"
            )

            if should_update and answer.strip():
                try:
                    await context.bot.edit_message_text(
                        answer[:4096],
                        chat_id=placeholder_message.chat_id,
                        message_id=placeholder_message.message_id,
                        parse_mode=parse_mode,
                        disable_web_page_preview=True
                    )
                    prev_answer = answer
                    last_update_time = current_time
                except telegram.error.BadRequest as e:
                    if not str(e).startswith("Message is not modified"):
                        try:
                            await context.bot.edit_message_text(
                                answer[:4096],
                                chat_id=placeholder_message.chat_id,
                                message_id=placeholder_message.message_id,
                                disable_web_page_preview=True
                            )
                            prev_answer = answer
                            last_update_time = current_time
                        except Exception:
                            pass

            await asyncio.sleep(0.01)

        new_dialog_message = {"user": [{"type": "text", "text": message}], "bot": full_answer, "date": datetime.now()}
        self.update_dialog_and_tokens(user_id, new_dialog_message, n_input_tokens, n_output_tokens)

        if n_first_dialog_messages_removed > 0:
            if n_first_dialog_messages_removed == 1:
                text = "‚úçÔ∏è <i>Note:</i> Your current dialog is too long, so your <b>first message</b> was removed from the context.\n Send /new command to start new dialog"
            else:
                text = f"‚úçÔ∏è <i>Note:</i> Your current dialog is too long, so <b>{n_first_dialog_messages_removed} first messages</b> were removed from the context.\n Send /new command to start new dialog"
            await update.message.reply_text(text, parse_mode=ParseMode.HTML)

    @staticmethod
    async def _get_non_streaming_response(chatgpt_instance: openai_utils.ChatGPT, message: str,
                                          dialog_messages: List[Dict], chat_mode: str) -> Tuple[str, int, int]:
        """–ü–æ–ª—É—á–∞–µ—Ç –Ω–µ–ø–æ—Ç–æ–∫–æ–≤—ã–π –æ—Ç–≤–µ—Ç –æ—Ç ChatGPT."""
        answer, (n_input_tokens, n_output_tokens), _ = await chatgpt_instance.send_message(
            message, dialog_messages=dialog_messages, chat_mode=chat_mode
        )
        return answer, n_input_tokens, n_output_tokens

    async def voice_message_handle(self, update: Update, context: CallbackContext, message: Optional[str] = None) -> \
            Optional[str]:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è."""
        if not await self.is_bot_mentioned(update, context):
            return

        await self.register_user_if_not_exists(update, context, update.message.from_user)
        if await self.is_previous_message_not_answered_yet(update, context):
            return

        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        if not await self.subscription_preprocessor(update, context):
            return

        chat_mode = self.db.get_user_attribute(user_id, "current_chat_mode")
        transcribed_text = await self._transcribe_voice_message(update, context, chat_mode)

        if chat_mode == "stenographer":
            return

        await self.message_handle(update, context, message=transcribed_text)
        return transcribed_text

    async def _transcribe_voice_message(self, update: Update, context: CallbackContext, chat_mode: str) -> str:
        """–¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ."""
        placeholder_text = "‚å®Ô∏è: <i>–†–∞—Å–ø–æ–∑–Ω–∞—é –∞—É–¥–∏–æ...</i>" if chat_mode == "stenographer" else "üé§: <i>–†–∞—Å–ø–æ–∑–Ω–∞—é –∞—É–¥–∏–æ...</i>"
        placeholder_message = await update.message.reply_text(placeholder_text, parse_mode=ParseMode.HTML)

        voice = update.message.voice
        voice_file = await context.bot.get_file(voice.file_id)

        buf = io.BytesIO()
        await voice_file.download_to_memory(buf)
        buf.name = "voice.oga"
        buf.seek(0)

        # –û–±–µ—Ä—Ç—ã–≤–∞–µ–º —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –≤—ã–∑–æ–≤ –≤ asyncio.to_thread
        transcribed_text = await asyncio.to_thread(openai_utils.transcribe_audio, buf)

        text = f"üé§: <i>{transcribed_text}</i>"

        user_id = update.message.from_user.id
        audio_duration_minutes = voice.duration / 60.0
        self.db.set_user_attribute(user_id, "n_transcribed_seconds",
                                   voice.duration + self.db.get_user_attribute(user_id, "n_transcribed_seconds"))

        if chat_mode == "stenographer":
            transcription_message = f"Your transcription is in: \n\n<code>{transcribed_text}</code>"
            await context.bot.edit_message_text(
                transcription_message,
                chat_id=placeholder_message.chat_id,
                message_id=placeholder_message.message_id,
                parse_mode=ParseMode.HTML
            )
        else:
            await context.bot.edit_message_text(
                text,
                chat_id=placeholder_message.chat_id,
                message_id=placeholder_message.message_id,
                parse_mode=ParseMode.HTML
            )

        return transcribed_text

    @staticmethod
    async def edited_message_handle(update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è."""
        if update.edited_message.chat.type == "private":
            text = "ü•≤ Unfortunately, message <b>editing</b> is not supported"
            await update.edited_message.reply_text(text, parse_mode=ParseMode.HTML)

    async def cancel_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /cancel."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        if user_id in user_tasks:
            user_tasks[user_id].cancel()
        else:
            await update.message.reply_text("<i>–ù–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å...</i>", parse_mode=ParseMode.HTML)

    @staticmethod
    async def _is_main_menu_button(text: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–æ–π –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é."""
        main_menu_buttons = [
            emoji.emojize("–ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É :money_bag:"),
            emoji.emojize("–í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º :red_heart:"),
            emoji.emojize("–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å :woman_and_man_holding_hands:"),
            emoji.emojize("–ü–æ–º–æ—â—å :heart_hands:"),
            emoji.emojize("–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å :smiling_face_with_sunglasses:"),
            emoji.emojize("–ù–∞–∑–∞–¥ :right_arrow_curving_left:"),
            emoji.emojize("–í—ã–≤–µ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"),
            emoji.emojize("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"),
            emoji.emojize("–î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"),
            emoji.emojize("–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É"),
            emoji.emojize("–ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"),
            emoji.emojize("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
        ]
        return text in main_menu_buttons

    async def handle_main_menu_buttons(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–æ–∫ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        text = update.message.text

        button_handlers = {
            emoji.emojize("–ü—Ä–æ–¥–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É :money_bag:"): self.subscription_handlers.subscription_handle,
            emoji.emojize("–í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º :red_heart:"): self.chat_mode_handlers.show_chat_modes_handle,
            emoji.emojize("–ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å :woman_and_man_holding_hands:"): self._handle_invite,
            emoji.emojize("–ü–æ–º–æ—â—å :heart_hands:"): self.help_handle,
            emoji.emojize("–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å :smiling_face_with_sunglasses:"): self.admin_handlers.admin_panel_handle,
            emoji.emojize("–ù–∞–∑–∞–¥ :right_arrow_curving_left:"): self._handle_back,
            emoji.emojize("–í—ã–≤–µ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"): self.admin_handlers.show_users_handle,
            emoji.emojize("–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"): self.admin_handlers.edit_user_handle,
            emoji.emojize("–î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"): self.admin_handlers.get_user_data_handle,
            emoji.emojize("–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É"): self.admin_handlers.broadcast_handle,
            emoji.emojize("–ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"): self.admin_handlers.handle_admin_panel_back,
            emoji.emojize("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"): self.admin_handlers.handle_main_menu_back,
        }

        handler = button_handlers.get(text)
        if handler:
            await handler(update, context)
        elif emoji.emojize(":green_circle:") in text or emoji.emojize(":red_circle:") in text:
            await self.subscription_handlers.subscription_handle(update, context)

    @staticmethod
    async def _handle_invite(update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–Ω–æ–ø–∫—É –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –¥—Ä—É–∑–µ–π."""
        await update.message.reply_text(
            "üë• <b>–ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–∑–µ–π!</b>\n\n"
            "–ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π –Ω–∞ –±–æ—Ç–∞ —Å –¥—Ä—É–∑—å—è–º–∏:\n"
            f"https://t.me/{context.bot.username}\n\n"
            "–ß–µ–º –±–æ–ª—å—à–µ –¥—Ä—É–∑–µ–π - —Ç–µ–º –ª—É—á—à–µ!",
            parse_mode=ParseMode.HTML
        )

    async def _handle_back(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–Ω–æ–ø–∫—É '–ù–∞–∑–∞–¥'."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)
        user_id = update.message.from_user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        reply_markup = await BotKeyboards.get_main_keyboard(user_id)
        await update.message.reply_text(
            "–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é...",
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )

    @staticmethod
    def _process_message_text(update: Update, context: CallbackContext, message: Optional[str]) -> str:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è."""
        _message = message or update.message.text

        if update.message.chat.type != "private":
            _message = _message.replace("@" + context.bot.username, "").strip()

        return _message

============================================================

bot/message_processor.py:
========================================
import asyncio
import logging
from datetime import datetime
from typing import Dict

import telegram
from telegram import (
    Update
)
from telegram.constants import ParseMode
from telegram.ext import (
    CallbackContext
)

import config
import database
from base_handler import BaseHandler

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
db = database.Database()
bot_instance = None
user_semaphores: Dict[int, asyncio.Semaphore] = {}
user_tasks: Dict[int, asyncio.Task] = {}


class MessageProcessor(BaseHandler):
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π —Å —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è."""

    async def is_bot_mentioned(self, update: Update, context: CallbackContext) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —É–ø–æ–º—è–Ω—É—Ç –ª–∏ –±–æ—Ç –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏."""
        try:
            message = update.message

            if message.chat.type == "private":
                return True

            if message.text and ("@" + context.bot.username) in message.text:
                return True

            if (message.reply_to_message and
                    message.reply_to_message.from_user.id == context.bot.id):
                return True

        except Exception:
            return True

        return False

    async def prepare_dialog(self, user_id: int, use_new_dialog_timeout: bool,
                             chat_mode: str, update: Update) -> None:
        """–ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –¥–ª—è –Ω–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è."""
        if use_new_dialog_timeout:
            last_interaction = self.db.get_user_attribute(user_id, "last_interaction")
            dialog_messages = self.db.get_dialog_messages(user_id)

            if (datetime.now() - last_interaction).seconds > config.new_dialog_timeout and len(dialog_messages) > 0:
                self.db.start_new_dialog(user_id)
                await update.message.reply_text(
                    f"–ó–∞–ø—É—Å–∫ –Ω–æ–≤–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞ (<b>{config.chat_modes[chat_mode]['name']}</b>) ‚úÖ",
                    parse_mode=ParseMode.HTML
                )

        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

    def update_dialog_and_tokens(self, user_id: int, new_dialog_message: Dict,
                                 n_input_tokens: int, n_output_tokens: int) -> None:
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –¥–∏–∞–ª–æ–≥ –∏ —Å—á–µ—Ç—á–∏–∫–∏ —Ç–æ–∫–µ–Ω–æ–≤."""
        current_model = self.db.get_user_attribute(user_id, "current_model")
        current_dialog_messages = self.db.get_dialog_messages(user_id, dialog_id=None)
        self.db.set_dialog_messages(user_id, current_dialog_messages + [new_dialog_message], dialog_id=None)

        self.db.update_n_used_tokens(user_id, current_model, n_input_tokens, n_output_tokens)


    async def edit_message_with_retry(self, context: CallbackContext, placeholder_message: telegram.Message,
                                      answer: str, chat_mode: str) -> None:
        """–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö."""
        parse_mode = {
            "html": ParseMode.HTML,
            "markdown": ParseMode.MARKDOWN
        }[config.chat_modes[chat_mode]["parse_mode"]]

        try:
            await context.bot.edit_message_text(
                answer[:4096],
                chat_id=placeholder_message.chat_id,
                message_id=placeholder_message.message_id,
                parse_mode=parse_mode,
                disable_web_page_preview=True
            )
        except telegram.error.BadRequest as e:
            if not str(e).startswith("Message is not modified"):
                await context.bot.edit_message_text(
                    answer[:4096],
                    chat_id=placeholder_message.chat_id,
                    message_id=placeholder_message.message_id,
                    disable_web_page_preview=True
                )

    async def handle_message_error(self, update: Update, error: Exception) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—à–∏–±–∫–∏ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏–π."""
        try:
            # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ
            logger.error(f"Error during message completion: {error}", exc_info=True)

            # –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–Ω—è—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            if hasattr(error, '__class__') and error.__class__.__name__ != 'int':
                error_text = f"‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
            else:
                error_text = f"‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ (–∫–æ–¥: {error}). –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."

            await update.message.reply_text(error_text, parse_mode=ParseMode.HTML)
        except Exception as e:
            logger.error(f"Error in error handler: {e}")
            # –†–µ–∑–µ—Ä–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            try:
                await update.message.reply_text("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞.")
            except:
                pass

    async def execute_user_task(self, user_id: int, task: asyncio.Task, update: Update) -> None:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç –∑–∞–¥–∞—á—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—Ç–º–µ–Ω—ã."""
        user_tasks[user_id] = task

        try:
            await task
        except asyncio.CancelledError:
            await update.message.reply_text("‚úÖ –ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ", parse_mode=ParseMode.HTML)
        finally:
            if user_id in user_tasks:
                del user_tasks[user_id]


============================================================

bot/openai_utils.py:
========================================
import base64
import logging
from io import BytesIO
from typing import Optional, List, AsyncGenerator, Tuple, Union

import openai
from openai import AsyncOpenAI

import config

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –≤—ã–Ω–µ—Å–µ–Ω—ã –≤ –≤–µ—Ä—Ö–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä
OPENAI_COMPLETION_OPTIONS = {
    "temperature": 0.7,
    "max_tokens": 2000,
    "top_p": 1,
    "frequency_penalty": 0,
    "presence_penalty": 0,
}

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª–∏–µ–Ω—Ç–∞ OpenAI (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
openai_client = AsyncOpenAI(
    api_key=config.openai_api_key,
    base_url=config.openai_api_base  # base_url –º–æ–∂–µ—Ç –±—ã—Ç—å None
)

logger = logging.getLogger(__name__)


def configure_logging():
    """–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
    level = logging.DEBUG if config.enable_detailed_logging else logging.CRITICAL
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(name)s - %(message)s',
        force=True  # –ü–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    )


configure_logging()


class ChatGPT:
    """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å ChatGPT"""

    # –ö—ç—à –¥–ª—è –ø—Ä–æ–º–ø—Ç–æ–≤ (–Ω–µ–±–æ–ª—å—à–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è)
    _prompt_cache = {}

    def __init__(self, model: str = "gpt-4o"):
        self.model = model
        self.is_claude_model = model.startswith("claude")
        self.logger = logger  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ª–æ–≥–≥–µ—Ä

    async def send_message_stream(
            self,
            message: str,
            dialog_messages: List[dict] = None,
            chat_mode: str = "assistant"
    ) -> AsyncGenerator[Tuple[str, str, Tuple[int, int], int], None]:
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ—Ç–æ–∫–æ–≤–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è."""
        if dialog_messages is None:
            dialog_messages = []

        try:
            self._validate_chat_mode(chat_mode)
            messages = self._generate_prompt_messages(message, dialog_messages, chat_mode)

            response = await openai_client.chat.completions.create(
                model=self.model,
                messages=messages,
                stream=True,
                **OPENAI_COMPLETION_OPTIONS
            )

            full_answer = ""
            chunk_counter = 0
            YIELD_EVERY_N_CHUNKS = 5  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —á–∞—Å—Ç–æ—Ç—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π

            async for chunk in response:
                if (chunk.choices and
                        chunk.choices[0].delta.content is not None):

                    chunk_content = chunk.choices[0].delta.content
                    full_answer += chunk_content
                    chunk_counter += 1

                    if chunk_counter % YIELD_EVERY_N_CHUNKS == 0:
                        yield "streaming", full_answer, (0, 0), 0

            # –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ —Ç–æ–∫–µ–Ω–∞–º–∏
            yield "finished", full_answer, (len(full_answer) // 4, 0), 0

        except Exception as e:
            logger.error(f"Streaming error for model {self.model}: {e}")
            raise

    async def send_message(
            self,
            message: str,
            dialog_messages: List[dict] = None,
            chat_mode: str = "assistant"
    ) -> Tuple[str, Tuple[int, int], int]:
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π"""
        if dialog_messages is None:
            dialog_messages = []

        self._validate_chat_mode(chat_mode)
        messages = self._generate_prompt_messages(message, dialog_messages, chat_mode)

        response = await openai_client.chat.completions.create(
            model=self.model,
            messages=messages,
            **OPENAI_COMPLETION_OPTIONS
        )

        answer = response.choices[0].message.content
        usage = response.usage
        return answer, (usage.prompt_tokens, usage.completion_tokens), 0

    def _validate_chat_mode(self, chat_mode: str) -> None:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è chat_mode —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        if chat_mode not in config.chat_modes:
            raise ValueError(f"Chat mode {chat_mode} is not supported")

    def _generate_prompt_messages(
            self,
            message: str,
            dialog_messages: List[dict],
            chat_mode: str,
            image_buffer: Optional[BytesIO] = None
    ) -> List[dict]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø—Ä–æ–º–ø—Ç–æ–≤"""
        # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –ø—Ä–æ–º–ø—Ç–æ–≤
        cache_key = f"system_{chat_mode}"
        if cache_key not in self._prompt_cache:
            self._prompt_cache[cache_key] = config.chat_modes[chat_mode]["prompt_start"]

        prompt = self._prompt_cache[cache_key]
        messages = [{"role": "system", "content": prompt}]

        # –ë–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –¥–∏–∞–ª–æ–≥–∞
        for msg in dialog_messages:
            messages.extend([
                {"role": "user", "content": msg["user"]},
                {"role": "assistant", "content": msg["bot"]}
            ])

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        if image_buffer is not None:
            encoded = base64.b64encode(image_buffer.read()).decode()
            messages.append({
                "role": "user",
                "content": [
                    {"type": "text", "text": message},
                    {"type": "image", "image": encoded},
                ]
            })
        else:
            messages.append({"role": "user", "content": message})

        return messages

    # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞
    def clear_cache(self):
        """–û—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞ –ø—Ä–æ–º–ø—Ç–æ–≤"""
        self._prompt_cache.clear()


async def transcribe_audio(audio_file) -> str:
    """–¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –∞—É–¥–∏–æ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
    try:
        transcript = await openai_client.audio.transcriptions.create(
            file=audio_file,
            model="whisper-1"
        )
        return transcript.text or ""
    except Exception as e:
        logger.error("Error transcribing audio: %s", e, exc_info=True)
        return ""


async def generate_images(prompt: str, model: str = "dall-e-3", n_images: int = 1, size: str = "1024x1024") -> List[
    str]:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–º—É –æ–ø–∏—Å–∞–Ω–∏—é."""
    try:
        # DALL-E 3 –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ 1 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞ –∑–∞–ø—Ä–æ—Å
        if model == "dall-e-3":
            n_images = 1
            # DALL-E 3 –∏–º–µ–µ—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä 1024x1024, 1792x1024, –∏–ª–∏ 1024x1792
            if size not in ["1024x1024", "1792x1024", "1024x1792"]:
                size = "1024x1024"

        # DALL-E 2 –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        elif model == "dall-e-2":
            if size not in ["256x256", "512x512", "1024x1024"]:
                size = "1024x1024"
            n_images = min(n_images, 10)  # –ú–∞–∫—Å–∏–º—É–º 10 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è DALL-E 2

        image_urls = []

        # –î–ª—è DALL-E 3 –¥–µ–ª–∞–µ–º –æ–¥–∏–Ω –∑–∞–ø—Ä–æ—Å
        if model == "dall-e-3":
            response = await openai.images.generate(
                model=model,
                prompt=prompt,
                size=size,
                quality="standard",
                n=1,
            )
            image_urls.append(response.data[0].url)

        # –î–ª—è DALL-E 2 –º–æ–∂–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
        elif model == "dall-e-2":
            response = await openai.images.generate(
                model=model,
                prompt=prompt,
                size=size,
                n=n_images,
            )
            image_urls = [img.url for img in response.data]

        return image_urls

    except Exception as e:
        logger.error(f"Error generating images: {e}")
        raise


async def generate_image_with_input(prompt: str, image_bytes: bytes) -> bytes:
    response = await openai_client.images.edit(
        model="gpt-image-1",
        prompt=prompt,
        image=[
            {
                "name": "input.png",
                "bytes": image_bytes
            }
        ],
        size="1024x1024"
    )

    # –î–æ—Å—Ç–∞—ë–º base64
    b64 = response.data[0].b64_json
    return base64.b64decode(b64)


async def generate_image(prompt: str) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–º—É –æ–ø–∏—Å–∞–Ω–∏—é."""
    try:
        response = await openai.images.generate(
            model="dall-e-3",
            prompt=prompt,
            size="1024x1024",
            quality="standard",
            n=1,
        )
        return response.data[0].url
    except Exception as e:
        logger.error(f"Error generating image: {e}")
        raise


============================================================

bot/payment.py:
========================================
import logging
from typing import Any, Dict

from telegram.ext import CallbackContext
from yookassa import Payment

from subscription_config import SubscriptionConfig, SubscriptionType

from utils import db, bot_instance

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –º–∞–≥–∏—á–µ—Å–∫–∏—Ö —Å—Ç—Ä–æ–∫
PAYMENT_RETURN_URL = "https://t.me/gptducksbot"
PAYMENT_CURRENCY = "RUB"
PAYMENT_CUSTOMER_EMAIL = "liliatchesnokova@gmail.com"
PAYMENT_TYPE_SUBSCRIPTION = "subscription"


def _create_payment_data(user_id: int, subscription_type: SubscriptionType) -> Dict[str, Any]:
    """–°–æ–∑–¥–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–ª–∞—Ç–µ–∂–∞ Yookassa."""
    price = SubscriptionConfig.get_price(subscription_type)
    description_config = SubscriptionConfig.get_description(subscription_type)
    description = f"–ü–æ–¥–ø–∏—Å–∫–∞ {description_config['name']}"

    return {
        "amount": {"value": price, "currency": PAYMENT_CURRENCY},
        "confirmation": {"type": "redirect", "return_url": PAYMENT_RETURN_URL},
        "capture": True,
        "description": description,
        "receipt": {
            "customer": {"email": PAYMENT_CUSTOMER_EMAIL},
            "items": [
                {
                    "description": description,
                    "quantity": "1.00",
                    "amount": {"value": price, "currency": PAYMENT_CURRENCY},
                    "vat_code": "1",
                    "payment_mode": "full_payment",
                    "payment_subject": "commodity",
                },
            ]
        },
        "metadata": {"user_id": user_id, "subscription_type": subscription_type.value}
    }


async def create_subscription_yookassa_payment(
        user_id: int,
        subscription_type: SubscriptionType,
        context: CallbackContext
) -> str:
    """
    –°–æ–∑–¥–∞–µ—Ç –ø–ª–∞—Ç–µ–∂ –≤ Yookassa –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é.
    """
    try:
        payment_data = _create_payment_data(user_id, subscription_type)
        payment = Payment.create(payment_data)

        db.create_payment(
            user_id=user_id,
            payment_id=payment.id,
            amount=payment_data["amount"]["value"],
            payment_type=PAYMENT_TYPE_SUBSCRIPTION,
            description=payment_data["description"]
        )

        return payment.confirmation.confirmation_url

    except Exception as e:
        logger.error(f"Error creating Yookassa subscription payment for user {user_id}: {e}")
        raise


async def process_successful_payment(payment_info: Any, user_id: int) -> None:
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —É—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç–µ–∂ –∏—Å–ø–æ–ª—å–∑—É—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é.
    """
    try:
        metadata = payment_info.metadata
        subscription_type = metadata.get('subscription_type')

        if not subscription_type:
            logger.warning(f"No subscription type in payment {payment_info.id} for user {user_id}")
            return

        logger.info(f"Processing successful payment {payment_info.id} for user {user_id}")

        subscription_type_enum = SubscriptionType(subscription_type)
        duration_days = SubscriptionConfig.get_duration(subscription_type_enum).days

        db.add_subscription(user_id, subscription_type_enum, duration_days)
        await send_subscription_confirmation(user_id, subscription_type_enum)
        logger.info(f"Subscription activated for user {user_id}: {subscription_type}")

    except Exception as e:
        logger.error(f"Error processing successful payment {getattr(payment_info, 'id', 'unknown')}: {e}")


async def send_subscription_confirmation(user_id: int, subscription_type: SubscriptionType) -> None:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ–± –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏.
    """
    try:
        user = db.user_collection.find_one({"_id": user_id})
        if not user:
            logger.warning(f"User {user_id} not found for subscription confirmation")
            return

        chat_id = user["chat_id"]
        duration_days = SubscriptionConfig.get_duration(subscription_type).days

        subscription_name = subscription_type.name.replace('_', ' ').title()
        message = (
            f"üéâ –ü–æ–¥–ø–∏—Å–∫–∞ *{subscription_name}* –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!\n"
            f"üìÖ –î–µ–π—Å—Ç–≤—É–µ—Ç *{duration_days} –¥–Ω–µ–π*\n\n"
            "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º –ø–æ –ø–æ–¥–ø–∏—Å–∫–µ!"
        )

        await bot_instance.send_message(chat_id=chat_id, text=message, parse_mode='Markdown')

    except Exception as e:
        logger.error(f"Error sending subscription confirmation to user {user_id}: {e}")

============================================================

bot/settings_handlers.py:
========================================
import logging
from datetime import datetime
from typing import Tuple, List

import telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import CallbackContext

import config
from base_handler import BaseHandler

logger = logging.getLogger(__name__)


class SettingsHandlers(BaseHandler):
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫."""

    def get_settings_menu(self, user_id: int) -> Tuple[str, InlineKeyboardMarkup]:
        """–°–æ–∑–¥–∞–µ—Ç –º–µ–Ω—é –Ω–∞—Å—Ç—Ä–æ–µ–∫."""
        text = "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏:"
        keyboard = [
            [InlineKeyboardButton("üß† –ú–æ–¥–µ–ª—å –Ω–µ–π—Ä–æ—Å–µ—Ç–∏", callback_data='model-ai_model')],
            [InlineKeyboardButton("üé® –ú–æ–¥–µ–ª—å —Ö—É–¥–æ–∂–Ω–∏–∫–∞", callback_data='model-artist_model')]
        ]
        return text, InlineKeyboardMarkup(keyboard)

    async def _check_access(self, update: Update, user_id: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        if str(user_id) not in config.roles.get('admin', []):
            await update.message.reply_text("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.")
            return False
        return True

    async def settings_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /settings."""
        await self.register_user_if_not_exists(update, context, update.message.from_user)

        if await self.is_previous_message_not_answered_yet(update, context):
            return

        user_id = update.message.from_user.id

        if not await self._check_access(update, user_id):
            return

        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())
        text, reply_markup = self.get_settings_menu(user_id)
        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

    async def set_settings_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–∫—É –Ω–∞—Å—Ç—Ä–æ–µ–∫ - –ø—Ä–æ–∫—Å–∏ –º–µ—Ç–æ–¥ –¥–ª—è model_settings_handler."""
        await self.model_settings_handler(update, context)

    def _create_model_buttons(self, available_models: list, current_model: str, prefix: str = "model") -> Tuple[
        list, list]:
        """–°–æ–∑–¥–∞–µ—Ç –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –º–æ–¥–µ–ª–∏."""
        claude_buttons = []
        other_buttons = []

        for model_key in available_models:
            title = config.models["info"][model_key]["name"]
            if model_key == current_model:
                title = "‚úÖ " + title

            callback_data = f"{prefix}-set_settings|{model_key}"
            button = InlineKeyboardButton(title, callback_data=callback_data)

            if "claude" in model_key.lower():
                claude_buttons.append(button)
            else:
                other_buttons.append(button)

        return other_buttons, claude_buttons

    def _format_model_info(self, model_key: str) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–¥–µ–ª–∏."""
        model_info = config.models["info"][model_key]
        description = model_info["description"]
        scores = model_info["scores"]

        details_text = f"{description}\n\n"
        for score_key, score_value in scores.items():
            details_text += f"{'üü¢' * score_value}{'‚ö™Ô∏è' * (5 - score_value)} ‚Äì {score_key}\n"

        details_text += "\n–í—ã–±–µ—Ä–∏—Ç–µ <b>–º–æ–¥–µ–ª—å</b>:"
        return details_text

    async def display_model_info(self, query, user_id, context):
        """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–æ–¥–µ–ª–∏."""
        current_model = self.db.get_user_attribute(user_id, "current_model")
        details_text = self._format_model_info(current_model)

        other_buttons, claude_buttons = self._create_model_buttons(
            config.models["available_text_models"], current_model
        )

        # –†–∞–∑–¥–µ–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞ –¥–≤–∞ —Ä—è–¥–∞
        half_size = len(other_buttons) // 2
        first_row = other_buttons[:half_size]
        second_row = other_buttons[half_size:]

        back_button = [InlineKeyboardButton("‚¨ÖÔ∏è", callback_data='model-back_to_settings')]
        reply_markup = InlineKeyboardMarkup([first_row, second_row, claude_buttons, back_button])

        try:
            await query.edit_message_text(
                text=details_text,
                parse_mode=ParseMode.HTML,
                reply_markup=reply_markup
            )
        except telegram.error.BadRequest as e:
            if "Message is not modified" not in str(e):
                raise e

    async def _handle_model_selection(self, query, user_id: int, model_key: str, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –º–æ–¥–µ–ª–∏."""
        if "claude" in model_key.lower() and not config.anthropic_api_key:
            await context.bot.send_message(
                chat_id=user_id,
                text="This bot does not have the Anthropic models available :(",
                parse_mode='Markdown'
            )
            return

        self.db.set_user_attribute(user_id, "current_model", model_key)
        await self.display_model_info(query, user_id, context)

    async def _handle_artist_model_selection(self, query, user_id: int, model_key: str) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –º–æ–¥–µ–ª–∏ —Ö—É–¥–æ–∂–Ω–∏–∫–∞."""
        preferences = self.db.get_user_attribute(user_id, "image_preferences")
        preferences["model"] = model_key

        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏ —Å–º–µ–Ω–µ –º–æ–¥–µ–ª–∏
        if model_key == "dall-e-2":
            preferences["quality"] = "standard"
        elif model_key == "dall-e-3":
            preferences["n_images"] = 1
        preferences["resolution"] = "1024x1024"

        self.db.set_user_attribute(user_id, "image_preferences", preferences)
        await self.artist_model_settings_handler(query, user_id)

    async def _update_artist_preference(self, user_id: int, preference_key: str, value: str) -> None:
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ö—É–¥–æ–∂–Ω–∏–∫–∞."""
        preferences = self.db.get_user_attribute(user_id, "image_preferences")
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º—É —Ç–∏–ø—É
        if preference_key == "n_images":
            value = int(value)
        preferences[preference_key] = value
        self.db.set_user_attribute(user_id, "image_preferences", preferences)

    async def model_settings_handler(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–¥–µ–ª–µ–π."""
        query = update.callback_query
        await query.answer()

        data = query.data
        user_id = query.from_user.id

        if data == 'model-ai_model':
            await self._handle_ai_model_settings(query, user_id)
        elif data.startswith(('claude-model-set_settings|', 'model-set_settings|')):
            _, model_key = data.split("|")
            await self._handle_model_selection(query, user_id, model_key, context)
        elif data == 'model-artist_model':
            await self.artist_model_settings_handler(query, user_id)
        elif data.startswith('model-artist-set_model|'):
            _, model_key = data.split("|")
            await self._handle_artist_model_selection(query, user_id, model_key)
        elif data.startswith("model-artist-set_"):
            await self._handle_artist_preference_update(query, user_id, data)
        elif data == 'model-back_to_settings':
            text, reply_markup = self.get_settings_menu(user_id)
            await query.edit_message_text(text=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)

    async def _handle_ai_model_settings(self, query, user_id: int) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ AI –º–æ–¥–µ–ª–∏."""
        current_model = self.db.get_user_attribute(user_id, "current_model")
        text = self._format_model_info(current_model)

        other_buttons, claude_buttons = self._create_model_buttons(
            config.models["available_text_models"], current_model
        )

        half_size = len(other_buttons) // 2
        first_row = other_buttons[:half_size]
        second_row = other_buttons[half_size:]
        back_button = [InlineKeyboardButton("‚¨ÖÔ∏è", callback_data='model-back_to_settings')]

        reply_markup = InlineKeyboardMarkup([first_row, second_row, claude_buttons, back_button])
        await query.edit_message_text(text=text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)

    async def _handle_artist_preference_update(self, query, user_id: int, data: str) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Ö—É–¥–æ–∂–Ω–∏–∫–∞."""
        _, action_data = data.split("|")

        if data.startswith("model-artist-set_images|"):
            await self._update_artist_preference(user_id, "n_images", action_data)
        elif data.startswith("model-artist-set_resolution|"):
            await self._update_artist_preference(user_id, "resolution", action_data)
        elif data.startswith("model-artist-set_quality|"):
            await self._update_artist_preference(user_id, "quality", action_data)

        await self.artist_model_settings_handler(query, user_id)

    def _create_artist_buttons(self, user_id: int) -> List[List[InlineKeyboardButton]]:
        """–°–æ–∑–¥–∞–µ—Ç –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –º–æ–¥–µ–ª–∏ —Ö—É–¥–æ–∂–Ω–∏–∫–∞."""
        current_preferences = self.db.get_user_attribute(user_id, "image_preferences")
        current_model = current_preferences.get("model", "dall-e-2")

        buttons = []
        for model_key in config.models["available_image_models"]:
            title = config.models["info"][model_key]["name"]
            if model_key == current_model:
                title = "‚úÖ " + title
            buttons.append(InlineKeyboardButton(title, callback_data=f"model-artist-set_model|{model_key}"))

        keyboard = [buttons]

        # –î–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–¥–µ–ª–∏
        if current_model == "dall-e-2":
            n_images = current_preferences.get("n_images", 1)
            images_buttons = [
                InlineKeyboardButton(
                    f"‚úÖ {i} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ" if i == n_images and i == 1 else
                    f"‚úÖ {i} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è" if i == n_images else
                    f"{i} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ" if i == 1 else f"{i} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è",
                    callback_data=f"model-artist-set_images|{i}"
                ) for i in range(1, 4)
            ]
            current_resolution = current_preferences.get("resolution", "1024x1024")
            resolution_buttons = [
                InlineKeyboardButton(
                    f"‚úÖ {res_key}" if res_key == current_resolution else res_key,
                    callback_data=f"model-artist-set_resolution|{res_key}"
                ) for res_key in config.models["info"]["dall-e-2"]["resolutions"]
            ]
            keyboard.extend([images_buttons, resolution_buttons])

        elif current_model == "dall-e-3":
            current_quality = current_preferences.get("quality", "standard")
            quality_buttons = [
                InlineKeyboardButton(
                    f"‚úÖ {quality_key}" if quality_key == current_quality else quality_key,
                    callback_data=f"model-artist-set_quality|{quality_key}"
                ) for quality_key in config.models["info"]["dall-e-3"]["qualities"]
            ]
            current_resolution = current_preferences.get("resolution", "1024x1024")
            resolution_buttons = [
                InlineKeyboardButton(
                    f"‚úÖ {res_key}" if res_key == current_resolution else res_key,
                    callback_data=f"model-artist-set_resolution|{res_key}"
                ) for res_key in config.models["info"]["dall-e-3"]["qualities"][current_quality]["resolutions"]
            ]
            keyboard.extend([quality_buttons, resolution_buttons])

        keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è", callback_data='model-back_to_settings')])
        return keyboard

    async def artist_model_settings_handler(self, query, user_id: int) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–¥–µ–ª–∏ —Ö—É–¥–æ–∂–Ω–∏–∫–∞."""
        current_preferences = self.db.get_user_attribute(user_id, "image_preferences")
        current_model = current_preferences.get("model", "dall-e-2")

        details_text = self._format_model_info(current_model)

        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—è—Å–Ω–µ–Ω–∏–µ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–¥–µ–ª–∏
        if current_model == "dall-e-2":
            details_text += "\n–î–ª—è —ç—Ç–æ–π –º–æ–¥–µ–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ:"
        elif current_model == "dall-e-3":
            details_text += "\n–î–ª—è —ç—Ç–æ–π –º–æ–¥–µ–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ:"

        keyboard = self._create_artist_buttons(user_id)
        reply_markup = InlineKeyboardMarkup(keyboard)

        try:
            await query.edit_message_text(
                text=details_text,
                parse_mode=ParseMode.HTML,
                reply_markup=reply_markup
            )
        except telegram.error.BadRequest as e:
            if "Message is not modified" not in str(e):
                raise e

============================================================

bot/subscription.py:
========================================
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from subscription_config import SubscriptionConfig


class SubscriptionType(Enum):
    FREE = "free"
    PRO_LITE = "pro_lite"
    PRO_PLUS = "pro_plus"
    PRO_PREMIUM = "pro_premium"


class Subscription:
    """
    –ö–ª–∞—Å—Å –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ SubscriptionConfig.
    """

    __slots__ = ('user_id', 'type', 'purchased_at', 'expires_at', 'requests_used', 'images_used')

    def __init__(
        self,
        user_id: int,
        subscription_type: SubscriptionType,
        purchased_at: datetime,
        expires_at: datetime,
        requests_used: int = 0,
        images_used: int = 0
    ):
        self.user_id = user_id
        self.type = subscription_type
        self.purchased_at = purchased_at
        self.expires_at = expires_at
        self.requests_used = requests_used
        self.images_used = images_used

    def is_active(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∞–∫—Ç–∏–≤–Ω–∞ –ª–∏ –ø–æ–¥–ø–∏—Å–∫–∞."""
        return datetime.now() < self.expires_at

    def _get_config(self) -> 'SubscriptionConfig':
        """–õ–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤."""
        from subscription_config import SubscriptionConfig
        return SubscriptionConfig

    def can_make_request(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –º–æ–∂–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–¥–µ–ª–∞—Ç—å –∑–∞–ø—Ä–æ—Å."""
        return self.is_active() and self._get_config().can_make_request(self.type, self.requests_used)

    def can_generate_image(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –º–æ–∂–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."""
        return self.is_active() and self._get_config().can_generate_image(self.type, self.images_used)

    def get_max_response_length(self) -> int:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É –æ—Ç–≤–µ—Ç–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏."""
        limits = self._get_config().get_usage_limits(self.type)
        return limits.get("max_response_length", 2000)

    def to_dict(self) -> Dict[str, Any]:
        """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –≤ —Å–ª–æ–≤–∞—Ä—å."""
        return {
            "user_id": self.user_id,
            "type": self.type.value,
            "purchased_at": self.purchased_at,
            "expires_at": self.expires_at,
            "requests_used": self.requests_used,
            "images_used": self.images_used
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Subscription':
        """–°–æ–∑–¥–∞–µ—Ç –ø–æ–¥–ø–∏—Å–∫—É –∏–∑ —Å–ª–æ–≤–∞—Ä—è."""
        return cls(
            user_id=data["user_id"],
            subscription_type=SubscriptionType(data["type"]),
            purchased_at=data["purchased_at"],
            expires_at=data["expires_at"],
            requests_used=data.get("requests_used", 0),
            images_used=data.get("images_used", 0)
        )


# –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã - –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è
# –í–º–µ—Å—Ç–æ –Ω–∏—Ö –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ SubscriptionConfig
SUBSCRIPTION_PRICES = {}
SUBSCRIPTION_DURATIONS = {}

============================================================

bot/subscription_config.py:
========================================
"""
–ú–æ–¥—É–ª—å –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–æ–∫.
–£—Å—Ç—Ä–∞–Ω—è–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∞—Ä–∏—Ñ–æ–≤ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–¥–ø–∏—Å–æ–∫.
"""

from datetime import timedelta
from typing import Dict, Any, List
from subscription import SubscriptionType


class SubscriptionConfig:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π –ø–æ–¥–ø–∏—Å–æ–∫."""

    # –ë–∞–∑–æ–≤—ã–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ –ø–æ–¥–ø–∏—Å–∫–∏
    _CONFIG = {
        SubscriptionType.FREE: {
            "price": 0,
            "duration": timedelta(days=7),
            "usage_limits": {
                "max_requests": 15,
                "max_images": 3,
                "max_response_length": 2000
            },
            "description": {
                "name": "–ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è",
                "features": "15 –∑–∞–ø—Ä–æ—Å–æ–≤ ‚Ä¢ 3 –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ‚Ä¢ –î–æ 2000 —Å–∏–º–≤–æ–ª–æ–≤"
            }
        },
        SubscriptionType.PRO_LITE: {
            "price": 499,
            "duration": timedelta(days=10),
            "usage_limits": {
                "max_requests": 1000,
                "max_images": 20,
                "max_response_length": 4000
            },
            "description": {
                "name": "Pro Lite",
                "features": "1000 –∑–∞–ø—Ä–æ—Å–æ–≤ ‚Ä¢ 20 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ‚Ä¢ –î–æ 4000 —Å–∏–º–≤–æ–ª–æ–≤"
            }
        },
        SubscriptionType.PRO_PLUS: {
            "price": 1290,
            "duration": timedelta(days=30),
            "usage_limits": {
                "max_requests": float('inf'),
                "max_images": float('inf'),
                "max_response_length": 32000
            },
            "description": {
                "name": "Pro Plus",
                "features": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã ‚Ä¢ –î–æ 32000 —Å–∏–º–≤–æ–ª–æ–≤"
            }
        },
        SubscriptionType.PRO_PREMIUM: {
            "price": 2990,
            "duration": timedelta(days=90),
            "usage_limits": {
                "max_requests": float('inf'),
                "max_images": float('inf'),
                "max_response_length": 32000
            },
            "description": {
                "name": "Pro Premium",
                "features": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã ‚Ä¢ –î–æ 32000 —Å–∏–º–≤–æ–ª–æ–≤"
            }
        }
    }

    # –ö—ç—à –¥–ª—è –ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫
    _PAID_SUBSCRIPTIONS = None

    @classmethod
    def get_price(cls, subscription_type: SubscriptionType) -> int:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ü–µ–Ω—É –ø–æ–¥–ø–∏—Å–∫–∏."""
        return cls._get_config_value(subscription_type, "price", 0)

    @classmethod
    def get_duration(cls, subscription_type: SubscriptionType) -> timedelta:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏."""
        return cls._get_config_value(subscription_type, "duration", timedelta(days=0))

    @classmethod
    def get_usage_limits(cls, subscription_type: SubscriptionType) -> Dict[str, Any]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–∏–º–∏—Ç—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏."""
        return cls._get_config_value(subscription_type, "usage_limits", {})

    @classmethod
    def get_description(cls, subscription_type: SubscriptionType) -> Dict[str, str]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏."""
        return cls._get_config_value(subscription_type, "description", {"name": "", "features": ""})

    @classmethod
    def _get_config_value(cls, subscription_type: SubscriptionType, key: str, default: Any) -> Any:
        """–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏."""
        config = cls._CONFIG.get(subscription_type, {})
        return config.get(key, default)

    @classmethod
    def get_all_paid_subscriptions(cls) -> List[SubscriptionType]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–ª–∞—Ç–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫."""
        if cls._PAID_SUBSCRIPTIONS is None:
            cls._PAID_SUBSCRIPTIONS = [
                sub_type for sub_type in cls._CONFIG.keys()
                if sub_type != SubscriptionType.FREE and cls.get_price(sub_type) > 0
            ]
        return cls._PAID_SUBSCRIPTIONS

    @classmethod
    def can_make_request(cls, subscription_type: SubscriptionType, requests_used: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –º–æ–∂–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–¥–µ–ª–∞—Ç—å –∑–∞–ø—Ä–æ—Å –ø–æ —Ç–µ–∫—É—â–µ–π –ø–æ–¥–ø–∏—Å–∫–µ."""
        max_requests = cls.get_usage_limits(subscription_type).get("max_requests", 0)
        return requests_used < max_requests

    @classmethod
    def can_generate_image(cls, subscription_type: SubscriptionType, images_used: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –º–æ–∂–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ —Ç–µ–∫—É—â–µ–π –ø–æ–¥–ø–∏—Å–∫–µ."""
        max_images = cls.get_usage_limits(subscription_type).get("max_images", 0)
        return images_used < max_images

============================================================

bot/subscription_handlers.py:
========================================
import logging
from datetime import datetime
from typing import Dict, Any

import telegram
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import CallbackContext

from base_handler import BaseHandler
from payment import create_subscription_yookassa_payment
from subscription import SubscriptionType
from subscription_config import SubscriptionConfig
from utils import HELP_MESSAGE

logger = logging.getLogger(__name__)


class SubscriptionHandlers(BaseHandler):
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–¥–ø–∏—Å–æ–∫ –∏ –ø–ª–∞—Ç–µ–∂–µ–π."""

    # –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —ç–º–æ–¥–∑–∏ –∏ —Ç–µ–∫—Å—Ç–∞
    _EMOJI_MAP = {
        "current_sub": "üìã",
        "expires": "üìÖ",
        "usage": "üìä",
        "images": "üé®",
        "subscriptions": "üîî",
        "payment": "üí≥",
        "back": "‚¨ÖÔ∏è",
        "error": "‚ùå",
        "pending": "‚è≥",
        "waiting": "üîÑ",
        "success": "‚úÖ",
        "canceled": "‚ùå",
        "unknown": "‚ùì"
    }

    _STATUS_EMOJI = {
        "pending": _EMOJI_MAP["pending"],
        "waiting_for_capture": _EMOJI_MAP["waiting"],
        "succeeded": _EMOJI_MAP["success"],
        "canceled": _EMOJI_MAP["canceled"]
    }

    async def subscription_handle(self, update: Update, context: CallbackContext) -> None:
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏."""
        try:
            user = self._get_user_from_update(update)
            await self.register_user_if_not_exists(update, context, user)

            user_id = user.id
            self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

            subscription_info = self.db.get_user_subscription_info(user_id)
            text = self._format_subscription_info(subscription_info)
            reply_markup = self._create_subscription_keyboard()

            await self._send_subscription_message(update, text, reply_markup)

        except Exception as e:
            logger.error(f"Error in subscription_handle: {e}")
            await self._handle_subscription_error(update)

    def _get_user_from_update(self, update: Update) -> telegram.User:
        """–ü–æ–ª—É—á–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ update."""
        return (update.message or update.callback_query).from_user

    def _format_subscription_info(self, subscription_info: Dict[str, Any]) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–ø–∏—Å–∫–µ."""
        text_parts = []

        # –¢–µ–∫—É—â–∞—è –ø–æ–¥–ø–∏—Å–∫–∞
        if subscription_info["is_active"]:
            if subscription_info["type"] != "free":
                expires_str = subscription_info["expires_at"].strftime("%d.%m.%Y")
                text_parts.extend([
                    f"{self._EMOJI_MAP['current_sub']} <b>–¢–µ–∫—É—â–∞—è –ø–æ–¥–ø–∏—Å–∫–∞:</b> {subscription_info['type'].upper()}",
                    f"{self._EMOJI_MAP['expires']} <b>–î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ:</b> {expires_str}"
                ])
            else:
                text_parts.append(f"{self._EMOJI_MAP['current_sub']} <b>–¢–µ–∫—É—â–∞—è –ø–æ–¥–ø–∏—Å–∫–∞:</b> –ë–ï–°–ü–õ–ê–¢–ù–ê–Ø")

            usage_text = self._format_usage_info(subscription_info)
            text_parts.append(usage_text)

        # –î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏
        text_parts.extend([
            "",
            f"{self._EMOJI_MAP['subscriptions']} <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏</b>",
            self._format_available_subscriptions()
        ])

        return "\n".join(text_parts)

    def _format_usage_info(self, subscription_info: Dict[str, Any]) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏."""
        subscription_type = SubscriptionType(subscription_info["type"])
        limits = SubscriptionConfig.get_usage_limits(subscription_type)

        max_requests = limits.get("max_requests", 0)
        max_images = limits.get("max_images", 0)

        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —Å –±–µ–∑–ª–∏–º–∏—Ç–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
        requests_text = self._format_limit_text(subscription_info['requests_used'], max_requests)
        images_text = self._format_limit_text(subscription_info['images_used'], max_images)

        return (
            f"{self._EMOJI_MAP['usage']} <b>–ó–∞–ø—Ä–æ—Å—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {requests_text}\n"
            f"{self._EMOJI_MAP['images']} <b>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {images_text}"
        )

    def _format_limit_text(self, used: int, limit: float) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç —Å –ª–∏–º–∏—Ç–æ–º."""
        if limit == float('inf'):
            return f"{used} (–±–µ–∑–ª–∏–º–∏—Ç–Ω–æ)"
        return f"{used}/{limit}"

    def _format_available_subscriptions(self) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–∫–∞—Ö."""
        text_parts = []

        for sub_type in SubscriptionConfig.get_all_paid_subscriptions():
            description = SubscriptionConfig.get_description(sub_type)
            price = SubscriptionConfig.get_price(sub_type)
            duration = SubscriptionConfig.get_duration(sub_type)

            text_parts.extend([
                f"<b>{description['name']}</b> - {price}‚ÇΩ / {duration.days} –¥–Ω–µ–π",
                f"   {description['features']}",
                ""
            ])

        return "\n".join(text_parts)

    def _create_subscription_keyboard(self) -> InlineKeyboardMarkup:
        """–°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–¥–ø–∏—Å–∫–∏."""
        buttons = []

        for sub_type in SubscriptionConfig.get_all_paid_subscriptions():
            description = SubscriptionConfig.get_description(sub_type)
            price = SubscriptionConfig.get_price(sub_type)

            name = f"{description['name']} - {price}‚ÇΩ"
            callback_data = f"subscribe|{sub_type.value}"
            buttons.append([InlineKeyboardButton(name, callback_data=callback_data)])

        return InlineKeyboardMarkup(buttons)

    async def _send_subscription_message(self, update: Update, text: str,
                                         reply_markup: InlineKeyboardMarkup) -> None:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø–æ–¥–ø–∏—Å–∫–∞—Ö."""
        try:
            if update.message:
                await update.message.reply_text(text, parse_mode=ParseMode.HTML, reply_markup=reply_markup)
            else:
                await update.callback_query.edit_message_text(
                    text, parse_mode=ParseMode.HTML, reply_markup=reply_markup
                )
        except telegram.error.BadRequest as e:
            if "Message is not modified" in str(e):
                return
            # Fallback –¥–ª—è callback query
            if update.callback_query:
                await update.callback_query.message.reply_text(
                    text, parse_mode=ParseMode.HTML, reply_markup=reply_markup
                )

    async def _handle_subscription_error(self, update: Update) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—à–∏–±–∫–∏ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –ø–æ–¥–ø–∏—Å–∫–∞–º–∏."""
        error_text = f"{self._EMOJI_MAP['error']} –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–æ–¥–ø–∏—Å–æ–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."

        if update.callback_query:
            await update.callback_query.message.reply_text(error_text, parse_mode=ParseMode.HTML)

    async def subscription_callback_handle(self, update: Update, context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç callback –≤—ã–±–æ—Ä–∞ –ø–æ–¥–ø–∏—Å–∫–∏."""
        query = update.callback_query
        await query.answer()

        data = query.data

        if data == "subscription_back":
            await self._handle_subscription_back(query)
        elif data.startswith("subscribe|"):
            await self._handle_subscription_payment(query, context)

    async def _handle_subscription_back(self, query: telegram.CallbackQuery) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–æ–∑–≤—Ä–∞—Ç –∏–∑ –º–µ–Ω—é –ø–æ–¥–ø–∏—Å–æ–∫."""
        reply_text = f"–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é...\n\n{HELP_MESSAGE}"

        try:
            await query.edit_message_text(
                reply_text, parse_mode=ParseMode.HTML, disable_web_page_preview=True
            )
        except telegram.error.BadRequest as e:
            if "Message is not modified" not in str(e):
                await query.message.reply_text(
                    reply_text, parse_mode=ParseMode.HTML, disable_web_page_preview=True
                )

    async def _handle_subscription_payment(self, query: telegram.CallbackQuery,
                                           context: CallbackContext) -> None:
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏."""
        try:
            _, subscription_type_str = query.data.split("|")
            subscription_type = SubscriptionType(subscription_type_str)

            payment_url = await create_subscription_yookassa_payment(
                query.from_user.id, subscription_type, context
            )

            text = self._format_payment_message(subscription_type)
            keyboard = self._create_payment_keyboard(payment_url)

            await query.edit_message_text(text, parse_mode=ParseMode.HTML, reply_markup=keyboard)

        except Exception as e:
            logger.error(f"Error in subscription payment: {e}")
            await query.edit_message_text(
                f"{self._EMOJI_MAP['error']} –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                parse_mode=ParseMode.HTML
            )

    def _format_payment_message(self, subscription_type: SubscriptionType) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ–ø–ª–∞—Ç–µ."""
        price = SubscriptionConfig.get_price(subscription_type)
        duration = SubscriptionConfig.get_duration(subscription_type)
        description = SubscriptionConfig.get_description(subscription_type)

        return (
            f"{self._EMOJI_MAP['payment']} <b>–û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ {description['name']}</b>\n\n"
            f"–°—Ç–æ–∏–º–æ—Å—Ç—å: <b>{price}‚ÇΩ</b>\n"
            f"–ü–µ—Ä–∏–æ–¥: <b>{duration.days} –¥–Ω–µ–π</b>\n"
            f"–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏: {description['features']}\n\n"
            "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã. –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ–ø–ª–∞—Ç—ã –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!"
        )

    def _create_payment_keyboard(self, payment_url: str) -> InlineKeyboardMarkup:
        """–°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –æ–ø–ª–∞—Ç—ã."""
        keyboard = [
            [InlineKeyboardButton(f"{self._EMOJI_MAP['payment']} –û–ø–ª–∞—Ç–∏—Ç—å", url=payment_url)],
            [InlineKeyboardButton(f"{self._EMOJI_MAP['back']} –ù–∞–∑–∞–¥", callback_data="subscription_back")]
        ]
        return InlineKeyboardMarkup(keyboard)

    async def my_payments_handle(self, update: Update, context: CallbackContext) -> None:
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç—É—Å pending –ø–ª–∞—Ç–µ–∂–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        user = update.message.from_user
        await self.register_user_if_not_exists(update, context, user)

        user_id = user.id
        self.db.set_user_attribute(user_id, "last_interaction", datetime.now())

        pending_payments = self.db.get_user_pending_payments(user_id)

        if not pending_payments:
            await update.message.reply_text(
                "–£ –≤–∞—Å –Ω–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö –ø–ª–∞—Ç–µ–∂–µ–π.",
                parse_mode=ParseMode.HTML
            )
            return

        text_lines = [
            f"{self._EMOJI_MAP['current_sub']} <b>–í–∞—à–∏ –æ–∂–∏–¥–∞—é—â–∏–µ –ø–ª–∞—Ç–µ–∂–∏:</b>\n"
        ]

        for payment in pending_payments:
            status_emoji = self._STATUS_EMOJI.get(payment["status"], self._EMOJI_MAP["unknown"])
            created_at = payment["created_at"].strftime("%d.%m.%Y %H:%M")

            text_lines.extend([
                f"{status_emoji} <b>{payment['amount']} ‚ÇΩ</b> - {payment['status']}",
                f"   ID: <code>{payment['payment_id']}</code>",
                f"   –°–æ–∑–¥–∞–Ω: {created_at}",
                ""
            ])

        text_lines.append("–ü–ª–∞—Ç–µ–∂–∏ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥.")

        await update.message.reply_text("\n".join(text_lines), parse_mode=ParseMode.HTML)

============================================================

bot/utils.py:
========================================
import asyncio
import logging
from typing import Dict, List

import config
import database

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
db = database.Database()
bot_instance = None
user_semaphores: Dict[int, asyncio.Semaphore] = {}
user_tasks: Dict[int, asyncio.Task] = {}

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã —Å–æ–æ–±—â–µ–Ω–∏–π
HELP_MESSAGE = """<b>–ö–æ–º–∞–Ω–¥—ã:</b>
/new ‚Äì –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥ üÜï
/retry ‚Äì –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∑–∞–ø—Ä–æ—Å üîÅ
/mode ‚Äì –í—ã–±—Ä–∞—Ç—å —Ä–µ–∂–∏–º
/subscription ‚Äì –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∞–º–∏ üîî
/my_payments ‚Äì –ú–æ–∏ –ø–ª–∞—Ç–µ–∂–∏ üìã
/help ‚Äì –ü–æ–º–æ—â—å ‚ùì

üé§ –í—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å <b>–≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b> –≤–º–µ—Å—Ç–æ —Ç–µ–∫—Å—Ç–∞

<blockquote>
1. –ß–∞—Ç –ø–æ–º–Ω–∏—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è 10 –º–∏–Ω—É—Ç. –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ ‚Äî /new
2. ¬´–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç¬ª ‚Äî —Ä–µ–∂–∏–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–∏–µ —Ä–µ–∂–∏–º—ã: /mode
</blockquote>
"""

HELP_GROUP_CHAT_MESSAGE = """–í—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –±–æ—Ç–∞ –≤ –ª—é–±–æ–π <b>–≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç</b> —á—Ç–æ–±—ã –ø–æ–º–æ–≥–∞—Ç—å –∏ —Ä–∞–∑–≤–ª–µ–∫–∞—Ç—å –µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤!

–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:
1. –î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç
2. –°–¥–µ–ª–∞–π—Ç–µ –µ–≥–æ <b>–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º</b>, —á—Ç–æ–±—ã –æ–Ω –º–æ–≥ –≤–∏–¥–µ—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è
3. –í—ã –≤–µ–ª–∏–∫–æ–ª–µ–ø–Ω—ã!

–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç –±–æ—Ç–∞ –≤ —á–∞—Ç–µ ‚Äì @ <b>—É–ø–æ–º—è–Ω–∏—Ç–µ</b> –µ–≥–æ –∏–ª–∏ <b>–æ—Ç–≤–µ—Ç—å—Ç–µ</b> –Ω–∞ –µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.
–ù–∞–ø—Ä–∏–º–µ—Ä: "{bot_username} –Ω–∞–ø–∏—à–∏ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏–µ –æ Telegram"
"""


# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
def split_text_into_chunks(text: str, chunk_size: int):
    """–†–∞–∑–¥–µ–ª—è–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ —á–∞—Å—Ç–∏ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞."""
    for i in range(0, len(text), chunk_size):
        yield text[i:i + chunk_size]


def update_user_roles_from_config(database: database.Database, roles: Dict[str, List[int]]) -> None:
    """–û–±–Ω–æ–≤–ª—è–µ—Ç —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏."""
    for role, user_ids in roles.items():
        for user_id in user_ids:
            database.user_collection.update_one(
                {"_id": user_id},
                {"$set": {"role": role}}
            )
    logger.info("User roles updated from config.")


def configure_logging() -> None:
    """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ."""
    log_level = logging.DEBUG if config.enable_detailed_logging else logging.CRITICAL
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s - %(name)s - %(message)s'
    )
    logger.setLevel(logging.getLogger().level)
    logging.getLogger('pymongo').setLevel(logging.WARNING)
    logging.getLogger('apscheduler').setLevel(logging.WARNING)
    logging.getLogger('urllib3').setLevel(logging.WARNING)


def get_user_semaphore(user_id: int) -> asyncio.Semaphore:
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø–æ–ª—É—á–∞–µ—Ç —Å–µ–º–∞—Ñ–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —Å–æ–∑–¥–∞–≤–∞—è –µ–≥–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏."""
    if user_id not in user_semaphores:
        user_semaphores[user_id] = asyncio.Semaphore(1)
        logger.info(f"Created semaphore for user {user_id}")
    return user_semaphores[user_id]

============================================================

